#+TITLE: My Emacs configuration
#+AUTHOR: Alexey Shiklomanov
#+PROPERTY: header-args :tangle yes :results silent :comments both

* Personal information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Alexey Shiklomanov"
      user-mail-address "alexey.shiklomanov@gmail.com")
#+END_SRC
* Package management
** Core emacs package manager

Load Emacs's internal package manager and tell it where to look for packages.

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'package)
  (setq package-enable-at-startup nil)
  (unless (assoc-default "org" package-archives)
    (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/")))
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/")))
  (unless (assoc-default "melpa-stable" package-archives)
    (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/")))
  (package-initialize))
#+END_SRC

** use-package

Bootstrap the ~use-package~ package manager.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile (require 'use-package))
#+END_SRC

** quelpa

For installing packages from source (e.g. GitHub).

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :ensure t
  :init
  (setq quelpa-update-melpa-p nil))
(use-package quelpa-use-package :ensure t)
#+END_SRC

** Restart Emacs in place

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :ensure t)
#+END_SRC
* Lisp libraries
** dash -- list manipulation

#+BEGIN_SRC emacs-lisp
(use-package dash :ensure t)
#+END_SRC
** f -- working with files

#+BEGIN_SRC emacs-lisp
(use-package f :ensure t)
#+END_SRC
** Custom libraries

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+END_SRC

* Native emacs settings
** custom.el file

Configure the ~custom.el~ file.
Mostly, I avoid this in favor of ~setq~ settings.
Note the use of ~f-touch~ to ensure that the file exists.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(f-touch custom-file)
(load custom-file)
#+END_SRC

** Backups and history

Create version-controlled backups of all files Emacs touches.
Save them in =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups"))
      delete-old-versions -1		; Don't delete old versions
      version-control t			; Version control backups
      make-backup-files t
      vc-make-backup-files t		; Backup files even if they are version controlled
      auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t))) ; Save file name changes
#+END_SRC

** Start emacs server

This allows me to open Emacs quickly from external programs, most importantly the command line.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

Also, configure the server for remote editing, based on [[https://andy.wordpress.com/2013/01/03/automatic-emacsclient/][this guide.]]

#+BEGIN_SRC emacs-lisp :tangle no
(setq server-use-tcp t
      server-port 9999)
(defun ans/server-start-and-copy ()
  "Start emacs server and copy file to PIC."
  (interactive)
  (server-start)
  (copy-file "~/.emacs.d/server/server" "/ssh:pic:.emacs.d/server/server" t))
#+END_SRC

** Other settings

Sentences should end with a single space, not a double space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Start with a blank scratch buffer.
No need for startup messages, splash screens, etc.

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC

Scroll conservatively, like vim does.
~scroll-margin~ is the guaranteed number of lines displayed above or below a cursor.
~scroll-conservatively~ determines how aggressively to auto-scroll.
Auto-scrolling in Emacs scrolls the buffer until the cursor is at the center of the screen, which is pretty distracting.
At a value >100, this means don't do any auto-scrolling (i.e. only ever scroll one line at a time).

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 2
      scroll-conservatively 101)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0
      abbrev-file-name (expand-file-name "abbrev_defs" user-emacs-directory)
      save-abbrevs 'silent
      auto-save-default nil
      column-number-mode t
      compilation-scroll-output t)

(setq-default indicate-empty-lines t)

(show-paren-mode 1)
(set-face-attribute 'show-paren-match nil :foreground nil :background "dim gray")

(tool-bar-mode -1)
(menu-bar-mode -1)
(blink-cursor-mode -1)
(global-hl-line-mode)
(winner-mode)				; Remember window configurations
(electric-pair-mode 1)
#+END_SRC

** PNNL mac settings

#+BEGIN_SRC emacs-lisp
(when (string-equal system-type "darwin")
  (setq exec-path (append exec-path '("/usr/local/bin")))
  (setq mac-option-modifier 'meta))

(use-package exec-path-from-shell
  :if (string-equal system-type "darwin")
  :ensure t
  :init
  (setq exec-path-from-shell-check-startup-files nil)
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

* Global variables

Related to bibtex references.

#+BEGIN_SRC emacs-lisp
(defvar ans/reference-dir (file-name-as-directory "~/Dropbox/references")
  "Root directory for storing my bibliography.")
(defvar ans/reference-dir-pdfs (file-name-as-directory (concat ans/reference-dir "pdfs"))
  "Subdirectory containing PDF files of papers in my bibliography.")
(defvar ans/reference-bibfile (concat ans/reference-dir "library.bib")
  "Full path to my personal bibtex file.")
(defvar ans/reference-notes (concat ans/reference-dir "notes.org")
  "Full path to reference-related notes.")
#+END_SRC

Automatically don't save before compiling.

#+BEGIN_SRC emacs-lisp
(setq compilation-save-buffers-predicate 'ignore)
#+END_SRC

By default, use spaces instead of tabs.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

* Text and prog mode hooks

#+BEGIN_SRC emacs-lisp
(defun ans-prog-mode-setup ()
  "My custom setup for prog mode."
  (toggle-truncate-lines 1)
  (flyspell-prog-mode)
  (setq comment-auto-fill-only-comments t)
  (auto-fill-mode 1))
(defun ans-text-mode-setup ()
  "My custom configuration for text mode."
  (visual-line-mode)
  (flyspell-mode))
(add-hook 'prog-mode-hook #'ans-prog-mode-setup)
(add-hook 'text-mode-hook #'ans-text-mode-setup)
#+END_SRC

* Aesthetics
** Color scheme and font

#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-tomorrow
  :ensure t
  :config
  (color-theme-sanityinc-tomorrow-night))

(defvar target-font "Input Mono Narrow-12" "My preferred Emacs font.")

(if (x-list-fonts target-font)
    (set-face-attribute 'default nil :font target-font))
#+END_SRC
** Cursor type

Don't show cursor in non-selected window.
This is mostly to avoid annoying visual artifacts of a hollow box cursor.

#+BEGIN_SRC emacs-lisp
(setq cursor-in-non-selected-windows nil)
#+END_SRC
** delight

Customize how major and minor modes appear in the modeline.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :ensure t
  :config
  (delight '((lispyville-mode nil lispyville)
             (yas-minor-mode nil yasnippet)
             (helm-mode nil helm)
             (company-mode nil company)
             (company-quickhelp-mode nil company-quickhelp)
             (evil-org-mode nil evil-org)
             (org-indent-mode nil org-indent)
             (flycheck-mode " üêõ" flycheck)
             (flyspell-mode " ùêÄùêÅùêÇ" flyspell)
             (visual-line-mode " ‚Ü©" simple)
             (adaptive-wrap-prefix-mode " ‚•±" adaptive-wrap)
             (auto-revert-mode " ‚Üª" autorevert)
             (undo-tree-mode nil undo-tree)
             (eldoc-mode nil eldoc)
             (winner-mode nil winner))))
#+END_SRC
** rainbow-delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook ((prog-mode) . rainbow-delimiters-mode))
#+END_SRC

** Mode line

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :config
  (sml/setup))
#+END_SRC
* Keybindings
** general

#+BEGIN_SRC emacs-lisp
(use-package general
  :ensure t)
#+END_SRC

Unbind keys that I'll need elsewhere.
~SPC~ is my leader key.
~C-u~ is useful for scrolling.
~\~ is my "local leader".

#+BEGIN_SRC emacs-lisp
(general-unbind
  :states '(motion normal visual)
  "SPC"
  "C-u"
  "\\"
  "K")
(general-unbind "M-SPC")
#+END_SRC

Create a custom definer to emulate Vim's leader key.
My leader key is SPACE.

#+BEGIN_SRC emacs-lisp
(general-create-definer ans-leader-def
  :prefix "SPC"
  :non-normal-prefix "M-SPC"
  :prefix-command 'ans-leader-command
  :prefix-map 'ans-leader-map)
#+END_SRC

** hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC
** evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil)
  :config
  (evil-mode)
  (defalias #'forward-evil-word #'forward-evil-symbol))
#+END_SRC

** Evil extensions
*** evil-collection
#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :ensure t
  :after evil
  :init
  (setq evil-collection-company-use-tng nil)
  :config
  (setq evil-collection-mode-list (remove 'company evil-collection-mode-list))
  (evil-collection-init))
#+END_SRC
*** evil-surround

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :after evil
  :config
  (global-evil-surround-mode))
#+END_SRC
*** evil-embrace
#+BEGIN_SRC emacs-lisp
(use-package evil-embrace
  :ensure t
  :after evil
  :init
  (setq evil-embrace-show-help-p nil)
  :config
  (evil-embrace-enable-evil-surround-integration)
  (add-hook 'org-mode-hook 'embrace-org-mode-hook)
  (add-hook 'LaTeX-mode-hook 'embrace-LaTeX-mode-hook))
#+END_SRC

*** evil-indent-textobject

#+BEGIN_SRC emacs-lisp
(use-package evil-indent-textobject
  :ensure t
  :after evil)
#+END_SRC

*** evil-nerd-commenter

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :ensure t
  :general
  (ans-leader-def
    :states '(normal visual)
    ";" 'evilnc-comment-or-uncomment-lines))
#+END_SRC

*** evil-easymotion

#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion
  :ensure t
  :after evil
  :config
  (general-def
    :states '(normal motion visual)
    "SPC SPC" evilem-map))
#+END_SRC

*** evil-exchange

#+BEGIN_SRC emacs-lisp
(use-package evil-exchange
  :ensure t
  :after evil
  :config
  (evil-exchange-install))
#+END_SRC

*** evil-numbers

#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
  :ensure t
  :after evil
  :init
  (defhydra evil-numbers-hydra ()
    "Increment or decrement numbers."
    ("=" evil-numbers/inc-at-pt "Increment")
    ("-" evil-numbers/dec-at-pt "Decrement"))
  :general
  (general-def
    :states 'normal
    "C-a" 'evil-numbers-hydra/body))
#+END_SRC

*** evil-magit

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  :ensure t
  :after magit)
#+END_SRC

*** evil-latex-textobjects

#+BEGIN_SRC emacs-lisp
(use-package evil-latex-textobjects
  :quelpa (evil-latex-textobjects :fetcher github :repo "hpdeifel/evil-latex-textobjects")
  :config
  (add-hook 'LaTeX-mode-hook 'turn-on-evil-latex-textobjects-mode))
#+END_SRC

*** evil-matchit

Temporarily disable this.

Supercharges =%= to jump between other stuff as well (e.g. if-else statements).
I also tried to expand it to R, but it doesn't currently work.

#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :disabled
  :ensure t
  :after evil
  :config
  (global-evil-matchit-mode 1)
  (require 'evil-matchit-sdk)
  (defvar ans/evilmi-r-match-tags
    '(("if" "else if" "else")
      ("function" "return" ())
      (("for" "while") ("break") ())))
  (defun ans/evilmi-r-get-tag ()
    (evilmi-sdk-get-tag ans/evilmi-r-match-tags
                        evilmi-sdk-extract-keyword-howtos))
  (defun ans/evilmi-r-jump (rlt num)
    (evilmi-sdk-jump rlt
                     num
                     ans/evilmi-r-match-tags
                     evilmi-sdk-extract-keyword-howtos))
  (plist-put evilmi-plugins 'r-mode '((ans/evilmi-r-get-tag ans/evilmi-r-jump))))
#+END_SRC
** Universal argument

Change universal argument from ~C-u~ (which I use for scrolling) to ~M-u~.

#+BEGIN_SRC emacs-lisp
(general-def "M-u" 'universal-argument)
#+END_SRC
** Insert state
#+BEGIN_SRC emacs-lisp
(general-def
  :states 'insert
  "j" (general-key-dispatch 'self-insert-command
        :timeout 0.25
        "k" 'evil-normal-state)
  "C-s" '(lambda ()(interactive)(upcase-word -1))
  "C-S-s" '(lambda ()(interactive)(capitalize-word -1)))
#+END_SRC

** Normal, visual, and motion states

#+BEGIN_SRC emacs-lisp
(general-def
  :states '(motion normal visual)
  ;; Move by visual lines
  "j" 'evil-next-visual-line
  "k" 'evil-previous-visual-line
  "gj" 'evilem-motion-next-line
  "gk" 'evilem-motion-previous-line
  "C-=" 'evil-window-increase-height
  "C--" 'evil-window-decrease-height
  "C-+" 'evil-window-increase-width
  "C-_" 'evil-window-decrease-width
  "C-0" 'balance-windows
  "C-)" 'shrink-window-if-larger-than-buffer
  "C-d" 'evil-scroll-down
  "C-u" 'evil-scroll-up)
#+END_SRC

** Leader mappings

#+BEGIN_SRC emacs-lisp
(ans-leader-def
  :states '(motion normal visual emacs)
  :keymaps 'override
  "b" 'helm-mini
  "f" 'helm-find-files
  ":" 'eval-expression
  "x" 'helm-M-x
  "sv" 'ans--reload-initfile
  "sx" (lambda() (interactive)(switch-to-buffer "*scratch*"))
  "ss" 'delete-trailing-whitespace
  "'" 'comment-dwim			; Insert right comment
  "vl" 'visual-line-mode
  "/" 'helm-occur
  "\"" 'helm-show-kill-ring
  "mm" 'compile
  "w"  'ans/buffer-window-hydra/body
  "p" 'ans/projectile-hydra/body
  "h" 'ans/help-hydra/body
  "o" 'ans/org-mode-hydra/body)
#+END_SRC

** Quick save with "S"

#+BEGIN_SRC emacs-lisp
(general-def
  :states 'normal
  "S" (general-predicate-dispatch nil
	(buffer-file-name) 'save-buffer))
#+END_SRC

*** Hydra for emacs help

#+BEGIN_SRC emacs-lisp
(defhydra ans/help-hydra (:exit t)
  "Emacs help."
  ("v" describe-variable "Variable")
  ("V" (describe-variable (variable-at-point)))
  ("f" describe-function "Function")
  ("F" (describe-function (function-called-at-point)))
  ("k" describe-key "Key")
  ("b" describe-bindings "Bindings")
  ("P" describe-package "Package")
  ("a" apropos-command "Apropos command")
  ("A" (let ((current-pre	fix-arg '(4))) (call-interactively 'apropos-command)) "Apropos all")
  ("m" describe-mode "Mode")
  ("M" (describe-variable current-major-mode) "Major mode")
  ("i" helm-info "Helm info"))
#+END_SRC
*** Hydra for projectile

#+BEGIN_SRC emacs-lisp
(defhydra ans/projectile-hydra (:exit t)
  "Projectile"
  ("p" helm-projectile "Helm projectile")
  ("o" helm-projectile-switch-project "Switch project")
  ("b" helm-projectile-switch-to-buffer "Switch buffer")
  ("f" helm-projectile-find-file "Find file")
  ("F" helm-projectile-find-file-in-known-projects "Find file in known projects")
  ("d" projectile-dired "Dired")
  ("D" projectile-dired-other-window "Dired other window")
  ("r" helm-projectile-recentf "Recent file")
  ("c" projectile-compile-project "Compile")
  ("e" projectile-run-eshell "Eshell")
  ("g" helm-projectile-ag "Ag search")
  ("E" projectile-edit-dir-locals "Edit dir-locals")
  ("Q" projectile-kill-buffers "Kill buffers")
  ("!" projectile-commander))
#+END_SRC
*** Hydra for buffer and window operations

#+BEGIN_SRC emacs-lisp
(defhydra ans/buffer-window-hydra (:exit t :hint nil)
  "
  Buffers: _w_:quit _W_:kill    Windows: _d_elete  _D_elete and kill    Frames: _f_:pop _F_:new     Split: _\\_:vert  _-_:horiz
  Switch:  _h__j__k__l_  Move (far = g): _H__J__K__L_    Misc: _r_evert   _s_ave as   _z_:undo   _Z_:redo"
  ("w" quit-window)
  ("W" (kill-buffer (current-buffer)))
  ("d" delete-window)
  ("D" kill-buffer-and-window)
  ("f" ans/pop-window-into-frame)
  ("F" make-frame-command)
  ("r" revert-buffer)
  ("s" write-file)
  ("\\" evil-window-vsplit)
  ("-" evil-window-split)
  ("j" windmove-down)
  ("h" windmove-left)
  ("k" windmove-up)
  ("l" windmove-right)
  ("J" buf-move-down)
  ("H" buf-move-left)
  ("K" buf-move-up)
  ("L" buf-move-right)
  ("gj" evil-window-move-very-bottom)
  ("gk" evil-window-move-very-top)
  ("gl" evil-window-move-far-right)
  ("gh" evil-window-move-far-left)
  ("z" winner-undo)
  ("Z" winner-redo))
#+END_SRC
** Evaluate lisp at point

Evaluate lisp at point.

#+BEGIN_SRC emacs-lisp
(general-def
  :keymaps 'lisp-mode-shared-map
  :states '(motion insert)
  "<C-return>" 'eval-defun)
#+END_SRC
** Evil-like movement in other modes

#+BEGIN_SRC emacs-lisp
(defun ans/add-evil-maps (keymap)
  "Add some basic navigation mappings (including hjkl) to KEYMAP."
  (general-def
    :keymaps keymap
    "h" 'evil-backward-char
    "l" 'evil-forward-char
    "k" 'evil-previous-visual-line
    "j" 'evil-next-visual-line
    "C-u" 'evil-scroll-up
    "C-d" 'evil-scroll-down
    "/" 'evil-search-forward
    "n" 'evil-search-next
    "N" 'evil-search-previous))

(ans/add-evil-maps 'occur-mode-map)
#+END_SRC
* Buffer and window management

** ace-window

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :init
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  :commands ace-window
  :general
  (general-def "M-o" 'ace-window))
#+END_SRC
** buffer-move

Swap buffer positions.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move :ensure t)
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :init
  (setq projectile-mode-line '(:eval (format " üïÆ%süïÆ" (projectile-project-name))))
  :config
  (projectile-mode))
#+END_SRC

Function to check if I'm inside of a projectile project.

#+BEGIN_SRC emacs-lisp
(defun ans/in-project-p ()
  "Check if current buffer is in a projectile project."
  (ignore-errors (projectile-project-root)))
#+END_SRC
** perspective

Like "tabs" in Emacs.
Note that this is lazy-loaded on =persp-switch= thanks to the =:commands= keyword.

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :init
  (setq persp-mode-prefix-key (kbd "<C-SPC>"))
  :config
  (persp-mode)
  :commands persp-switch)
#+END_SRC
** treemacs

Better file and project manager.
Note that all of these are lazy-loaded thanks to the =:general= keyword.

#+BEGIN_SRC emacs-lisp
(use-package treemacs
  :ensure t
  :general
  (ans-leader-def
    :states 'normal
    "dd" 'treemacs
    "df" 'treemacs-find-file
    "dw" 'treemacs-select-window
    "dp" 'treemacs-projectile
    "db" 'treemacs-bookmark))

(use-package treemacs-evil
  :after treemacs evil
  :ensure t)

(use-package treemacs-projectile
  :after treemacs projectile
  :ensure t)
#+END_SRC
** zoom-window

Temporarily "zoom" windows into full screen, like in ~tmux~.

#+BEGIN_SRC emacs-lisp
(use-package zoom-window
  :ensure t
  :config
  (ans-leader-def
    :states '(normal motion)
    "z" 'zoom-window-zoom))
#+END_SRC
* Version control
** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :general
  (ans-leader-def
    :states 'normal
    "g s" 'magit-status)
  :config
  (general-def
    :states 'normal
    :keymaps 'magit-status-mode-map
    "gd" 'magit-diff-toggle-refine-hunk))
#+END_SRC
** magithub

#+BEGIN_SRC emacs-lisp
(use-package magithub
  :ensure t
  :after magit
  :config
  (magithub-feature-autoinject t)
  (ans-leader-def
    :states '(normal motion emacs)
    "gd" 'magithub-dashboard)
  (general-def
    :keymaps 'magithub-dash-map
    :states 'normal
    "gu" 'magithub-dashboard-show-read-notifications-toggle))
#+END_SRC
* Filetype modes
** markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :init
  (setq markdown-command "pandoc"))
#+END_SRC

Also, add Pandoc support.

#+BEGIN_SRC emacs-lisp
(use-package pandoc-mode
  :ensure t
  :config
  (add-hook 'markdown-mode-hook 'pandoc-mode))
#+END_SRC
** fence-edit

Edit code blocks in a separate window.

#+BEGIN_SRC emacs-lisp
(use-package fence-edit
  :quelpa (fence-edit :fetcher github :repo "aaronbieber/fence-edit.el")
  :config
  (add-to-list 'fence-edit-blocks '("^```{r.*}" "^```$" R))
  (add-to-list 'fence-edit-blocks '("^```{tikz.*}" "^```$" latex))
  (general-def
    :keymaps 'markdown-mode-map
    :states '(motion normal visual)
    "\\e" 'fence-edit-code-at-point)
  (general-def
    :keymaps 'fence-edit-mode-map
    "C-c C-c" 'fence-edit-exit
    "C-c C-k" 'fence-edit-abort))
#+END_SRC
** pdf-tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  ;; :mode (("\\.pdf\\'" . pdf-view-mode))
  :config
  (pdf-tools-install)
  (general-def
    :states 'normal
    :keymaps 'pdf-view-mode-map
    "<" 'pdf-history-backward
    ">" 'pdf-history-forward))
#+END_SRC
** mmm-mode

Currently disabled.

#+BEGIN_SRC emacs-lisp
(use-package mmm-mode
  :disabled
  :ensure t
  :init
  (setq mmm-global-mode 'maybe
	mmm-submode-decoration-level 1
	mmm-parse-when-idle t
	mmm-idle-timer-delay 1)
  :config
  (mmm-add-classes
   '((ans-mmm-org-elisp
      :submode emacs-lisp-mode
      :face org-block
      :front "#\+BEGIN_SRC emacs-lisp"
      :front-offset -1
      :back "#\+END_SRC")
     (ans-mmm-org-r
      :submode R-mode
      :face org-block
      :front "#\+BEGIN_SRC R"
      :front-offset -1
      :back "\n#\+END_SRC")
     (ans-rmarkdown
      :submode r-mode
      :front "^```{r.*}"
      :front-offset -1
      :back "^```$")
     (ans-latex
      :submode latex-mode
      :front "^```{tikz.*}"
      :front-offset -1
      :back "^```$")))
  (mmm-add-mode-ext-class 'org-mode nil 'ans-mmm-org-elisp)
  (mmm-add-mode-ext-class 'org-mode nil 'ans-mmm-org-r))

;; (mmm-add-mode-ext-class 'markdown-mode "\\.Rmd\\'" 'ans-rmarkdown)
;; (mmm-add-mode-ext-class 'markdown-mode "\\.Rmd\\'" 'ans-latex))

#+END_SRC
** yaml

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :mode "\\.yml\\'")
#+END_SRC
** csv-mode

Currently disabled.

#+BEGIN_SRC emacs-lisp
(defun ans/csv-mode-settings ()
  "Custom settings for CSV mode."
  (toggle-truncate-lines -1))

(use-package csv-mode
  :disabled
  :ensure t
  :mode "\\.csv\\'"
  :hook (csv-mode . ans/csv-mode-settings))
#+END_SRC
** open with

Set default external programs for certain filetypes.

#+BEGIN_SRC emacs-lisp
(use-package openwith
  :if (string-equal system-type "darwin")
  :ensure t
  :init
  (setq openwith-associations '(("\\.pdf\\'" "open" (file))))
  :config
  (openwith-mode t))
#+END_SRC
** Docker

Major modes for editing ~docker~ and ~docker-compose~ files.

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :quelpa (dockerfile-mode :fetcher github :repo "ashiklom/dockerfile-mode")
  :mode "\\`Dockerfile")

(defun ans/dockerfile-settings ()
  "Settings for dockerfile-mode"
  (setq indent-tabs-mode nil))

(add-hook 'dockerfile-mode-hook 'ans/dockerfile-settings)

(use-package docker-compose-mode
  :ensure t)
#+END_SRC

The [[https://github.com/Silex/docker.el][docker]] package for performing docker commands directly from within Emacs.

#+BEGIN_SRC emacs-lisp
(use-package docker
  :ensure t
  :general
  (ans-leader-def
    :states 'normal
    "D" 'docker))
#+END_SRC
** Polymode

Multiple major modes in a single file.
Mostly useful for R markdown files (R + markdown).

#+BEGIN_SRC emacs-lisp
(use-package polymode
  :ensure t
  :config
  (general-def
    :states '(normal motion)
    :keymaps 'polymode-mode-map
    "g]" 'polymode-next-chunk
    "g[" 'polymode-previous-chunk
    "g-" 'polymode-kill-chunk))

(use-package poly-markdown
  :ensure t
  :config
  (ans-leader-def
    :states 'normal
    :keymaps 'poly-markdown-mode-map
    "`" 'ans/chunk-hydra/body)
  (general-def
    :states 'insert
    :keymaps 'poly-markdown-mode-map
    "C-'" 'ans/chunk-hydra/body))

(defun ans/insert-chunk-and-enter (chunktype)
  "Insert chunk of type CHUNKTYPE and enter it."
  (insert "```" chunktype "\n\n```")
  (previous-line)
  (beginning-of-line))

(defhydra ans/chunk-hydra (:exit t)
  "Insert chunks."
  ("`" (ans/insert-chunk-and-enter "") "Plain")
  ("r" (ans/insert-chunk-and-enter "{r}") "R (knitr)")
  ("R" (ans/insert-chunk-and-enter "r") "R (plain)")
  ("-" ans/poly-split-chunk-here "Split")
  ("SPC" polymode-toggle-chunk-narrowing))

(defun ans/poly-split-chunk-here ()
  "Split chunk into two chunks at point."
  (interactive)
  (beginning-of-line)
  (insert "```\n\n```")
  (previous-line)
  (beginning-of-line))

;; Other modes that could be useful
;; (use-package poly-R
;;   :ensure t)

;; (use-package poly-org
;;   :ensure t)
#+END_SRC
** web-mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode (("\\.php\\'" . web-mode)
	 ("\\.html\\'" . web-mode)))
#+END_SRC
** Python
Configure Elpy -- interactive Python development environment.

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :hook python-mode
  :init
  (setq python-shell-interpreter "jupyter"
        python-shell-interpreter-args "console --simple-prompt"
        python-shell-prompt-detect-failure-warning nil)
  :config
  (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
  (elpy-enable)
  (general-def
    :states 'normal
    :keymaps 'elpy-mode-map
    :prefix "\\"
    "rf" 'run-python
    "l" 'elpy-shell-send-statement
    "d" 'elpy-shell-send-statement-and-step
    "aa" 'elpy-shell-send-buffer))
#+END_SRC
* Utility functions
** Rename buffer and file

#+BEGIN_SRC emacs-lisp
(defun rename-this-buffer-and-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

(evil-ex-define-cmd "rename" 'rename-this-buffer-and-file)
#+END_SRC
** Delete buffer and file

#+BEGIN_SRC emacs-lisp
(defun ans/delete-file-and-buffer ()
  "Kill the current buffer and delete the associated file."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (progn
        (delete-file filename)
        (message "Deleted file %s" filename)
        (kill-buffer)))))

(evil-ex-define-cmd "dkill" 'ans/delete-file-and-buffer)
#+END_SRC
** Switch to most recently used buffer

#+BEGIN_SRC emacs-lisp
(defun ans-switch-to-mru-buffer ()
  "Switch to most-recently-used (MRU) buffer."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))
#+END_SRC
** Reload init file

#+BEGIN_SRC emacs-lisp
(defun ans--reload-initfile ()
  "Reload the Emacs init file."
  (interactive)
  (load-file (expand-file-name "init.el" user-emacs-directory)))
#+END_SRC
** Edit init file

#+BEGIN_SRC emacs-lisp
(defun ans--edit-initfile ()
  "Edit the Emacs init file."
  (interactive)
  (find-file (expand-file-name "init.el" user-emacs-directory)))
#+END_SRC
** Pop window into own frame

#+BEGIN_SRC emacs-lisp
(defun ans/pop-window-into-frame ()
  "Pop current window into its own frame."
  (interactive)
  (let ((buffer (current-buffer)))
    (unless (one-window-p)
      (delete-window))
    (display-buffer-pop-up-frame buffer nil)))
#+END_SRC
** Align commas

Align a comma-separated table inside the current selection.
This is useful for complex R ~tribbles~.

#+BEGIN_SRC emacs-lisp
(defun ans/align-comma (start end)
  "Align comma-separated table."
  (interactive "r")
  (align-regexp start end
		"\\(\\s-*\\)," 1 1 t))

#+END_SRC
** Run shell commands

#+BEGIN_SRC emacs-lisp
(defun ans/shell-send-line ()
  "Run line at point as shell command."
  (interactive)
  (shell-command (buffer-substring-no-properties (line-beginning-position) (line-end-position))))

(defun ans/shell-send-region (start end)
  "Run selection as shell command."
  (interactive "r")
  (shell-command (buffer-substring-no-properties start end)))

(ans-leader-def
  :states 'normal
  "@" 'ans/shell-send-line)

(ans-leader-def
  :states 'visual
  "@" 'ans/shell-send-region)
#+END_SRC
* Helm

Core helm configuration.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :demand
  :init
  (require 'helm-config)
  (setq helm-buffers-fuzzy-matching t)
  (setq helm-autoresize-mode t)
  (setq helm-buffer-max-length 20)
  (setq helm-mode-fuzzy-match t)
  ;; (setq helm-grep-ag-command
  ;; 	"rg --color=always --smart-case --no-heading --line-number %s %s %s")
  (setq helm-autoresize-max-height 40)
  (setq helm-display-function 'ans/helm-hsplit-frame)
  (setq helm-findutils-search-full-path t)
  ;; (setq find-program "fd")
  :config
  (helm-mode 1)
  (helm-autoresize-mode 1)
  ;; (use-package helm-rg :ensure t)
  :general
  (ans-leader-def
    :states 'normal
    "f" 'helm-find-files
    "F" 'helm-find)
  (general-def
    :keymaps 'helm-map
    "TAB" 'helm-execute-persistent-action
    "<right>" 'right-char
    "<left>" 'left-char
    "C-z" 'helm-select-action
    "C-n" 'helm-next-line
    "C-p" 'helm-previous-line
    "C-d" 'helm-next-page
    "C-u" 'helm-previous-page
    "C-S-n" 'helm-next-source
    "C-S-p" 'helm-previous-source
    "C-l" 'helm-yank-selection
    "<C-backspace>" 'backward-kill-word)
  (general-def
    :keymaps '(helm-find-files-map helm-projectile-find-file-map)
    "<right>" 'right-char
    "<left>" 'left-char
    "<C-backspace>" 'backward-kill-word)
  (general-def
    :keymaps '(helm-buffer-map)
    "C-;" 'ans/helm-buffer-hydra/body))
#+END_SRC

Buffer mode hydra.
See [[https://github.com/abo-abo/hydra/wiki/Helm-2][here]] and [[https://github.com/abo-abo/hydra/wiki/Helm-2][here]] for inspiration.

#+BEGIN_SRC emacs-lisp
(defhydra ans/helm-buffer-hydra (:color pink)
  "Helm buffer"
  ("k" helm-previous-line "Previous")
  ("j" helm-next-line "Next")
  ("{" helm-previous-source "Previous source")
  ("}" helm-next-source "Next source")
  ("C-d" helm-next-page "Pg Down")
  ("C-u" helm-previous-page "Pg Up")
  ("gg" helm-beginning-of-buffer "Top")
  ("G" helm-end-of-buffer "Bottom")
  ("m" helm-toggle-visible-mark "Mark")
  ("M" helm-toggle-all-marks "Mark all")
  ("A" helm-mark-all "Mark all")
  ("U" helm-unmark-all "Unmark all")
  ("x" helm-buffer-run-kill-persistent "Kill")
  ("gr" helm-buffer-run-grep "Grep")
  ("r" helm-buffer-run-rename-buffer "Rename")
  ("y" helm-yank-selection "Yank")
  ("v" helm-execute-persistent-action "View")
  ("f" helm-follow-mode "Follow")
  ("K" helm-scroll-other-window-down "Scroll down")
  ("J" helm-scroll-other-window "Scroll up")
  ("C-z" helm-select-action "Select action")
  ("i" nil "Insert")
  ("<escape>" 'helm-keyboard-quit "Back"))
#+END_SRC

** Split windows for helm

#+BEGIN_SRC emacs-lisp
(defun ans/hsplit-frame ()
  "Split window entirely below the current frame."
  (split-window (frame-root-window) nil 'below))

(defun ans/helm-hsplit-frame (buffer &optional _resume)
  "Open new window below frame, switch to it, and open BUFFER."
  (ans/hsplit-frame)
  (evil-window-bottom-right)
  (switch-to-buffer buffer))
#+END_SRC
** helm-ag

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :ensure t
  :after helm)
#+END_SRC
** helm-projectile

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t
  :init
  (setq helm-projectile-fuzzy-match t
        helm-projectile-truncate-lines t
        projectile-completion-system 'helm
        projectile-switch-project-action 'helm-projectile)
  :config
  (helm-projectile-on)
  (ans-leader-def
    :states '(motion normal)
    "rg" (general-predicate-dispatch 'helm-ag
           (ans/in-project-p) 'helm-projectile-ag)
    "rG" 'helm-do-ag))
#+END_SRC
** helm-org-rifle

#+BEGIN_SRC emacs-lisp
(use-package helm-org-rifle
  :ensure t
  :init
  (setq helm-org-rifle-test-against-path t)
  :commands (helm-org-rifle-agenda-files helm-org-rifle-current-buffer))
#+END_SRC
** helm-swoop

#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :init
  (setq helm-swoop-split-direction 'split-window-horizontally)
  :general
  (ans-leader-def
    :states '(motion normal)
    "ii" 'helm-swoop
    "ib" 'helm-multi-swoop-all
    "ip" 'helm-multi-swoop-projectile
    "i0" 'helm-swoop-back-to-last-point))
#+END_SRC
** helm-descbinds

#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :after helm
  :config
  (helm-descbinds-mode))
#+END_SRC
** helm-unicode

For easier unicode entry.

#+BEGIN_SRC emacs-lisp
(use-package helm-unicode
  :ensure t
  :general
  (general-def
    :states 'insert
    "C-u" 'helm-unicode))
#+END_SRC
* Company

** Company core configuration

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :commands (global-company-mode company-complete ans/directory-file-backend)
  :init
  (setq company-selection-wrap-around t)
  (setq company-idle-delay nil)
  (setq company-dabbrev-code-everywhere t
	company-dabbrev-code-modes t)
  :config
  (global-company-mode)
  ;; Thanks to this:
  ;; https://github.com/otijhuis/evil-emacs.d/blob/7c122b0e05c367192444a85d12323487422b793b/config/evil-settings.el#L38-L39
  (add-hook 'evil-insert-state-exit-hook (lambda ()(company-abort)))
  ;; See discussion in: https://github.com/expez/company-quickhelp/issues/17
  (add-hook 'company-completion-started-hook 'ans/set-company-maps)
  (add-hook 'company-completion-finished-hook 'ans/unset-company-maps)
  (add-hook 'company-completion-cancelled-hook 'ans/unset-company-maps)
  (add-to-list 'company-backends 'ans/org-keyword-backend)
  :general
  (general-def
    :states 'insert
    ;; See below for discussion of company-dabbrev-code
    ;; https://github.com/company-mode/company-mode/issues/360
    "C-f" 'ans/directory-file-backend
    "C-l" 'company-complete		; Note that this includes company-files
    )
  (general-def
    :states 'insert
    :keymaps 'prog-mode-map
    "C-n" 'company-dabbrev-code
    "C-p" 'company-dabbrev-code
    "C-S-n" 'company-dabbrev
    "C-S-p" 'company-dabbrev)
  (general-def
    :states 'insert
    :keymaps 'text-mode-map
    "C-n" 'company-dabbrev
    "C-p" 'company-dabbrev
    "C-S-n" 'company-dabbrev-code
    "C-S-p" 'company-dabbrev-code))
#+END_SRC

Additional functions needed to make ~company-quickhelp~ respect my keybindings.

#+BEGIN_SRC emacs-lisp
(defun ans/unset-company-maps (&rest unused)
  "Set default mappings (outside of company).
  Arguments (UNUSED) are ignored."
  (general-def
    :states 'insert
    :keymaps 'override
    "C-n" nil
    "C-p" nil
    "C-l" nil))

(defun ans/set-company-maps (&rest unused)
  "Set maps for when you're inside company completion.
  Arguments (UNUSED) are ignored."
  (general-def
    :states 'insert
    :keymaps 'override
    "C-n" 'company-select-next
    "C-p" 'company-select-previous
    "C-l" 'ans-company-complete-continue))

(defun ans-company-complete-continue ()
  "Insert the result of a completion, then re-start completion.
This makes repeat completions easier (e.g. when completing long file paths)."
  (interactive)
  (company-complete-selection)
  (company-complete))
#+END_SRC

** company-quickhelp

#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :ensure t
  :after company
  :config
  (company-quickhelp-mode))
#+END_SRC

** Custom backends

*** Complete inside directory or projectile project

#+BEGIN_SRC emacs-lisp
(defun ans/directory-completion-candidates (prefix)
  "List files in projectile or current buffer directory that match PREFIX."
  (let* ((starting-directory
          (condition-case nil
              (projectile-project-root)
            (error "./")))
         (my-prefix-base (file-name-nondirectory prefix))
         (my-prefix-dir (file-name-directory prefix))
         (my-complete-dir (concat starting-directory my-prefix-dir))
         (my-completions-all
          (file-name-all-completions my-prefix-base my-complete-dir))
         (my-completions (-difference my-completions-all '("./" "../"))))
    (mapcar (lambda (file) (concat my-prefix-dir file)) my-completions)))

(defun ans/directory-file-backend (command &optional arg &rest ignored)
  "Complete files in current or projectile project directory.

COMMAND is command called by company.
ARG is the set of company completion arguments.
IGNORED are arguments ignored by company."
  (interactive (list 'interactive))
  (case command
    (interactive (company-begin-backend 'ans/directory-file-backend))
    (prefix (company-grab-line "\\(?:[\"\']\\|\\s-\\|^\\)\\(.*?\\)" 1))
    (candidates
     (remove-if-not
      (lambda (c) (string-prefix-p arg c))
      (ans/directory-completion-candidates arg)))))
#+END_SRC

*** Org keywords

#+BEGIN_SRC emacs-lisp
(defun ans/org-keyword-backend (command &optional arg &rest ignored)
  "Completion backend for org keywords (COMMAND, ARG, IGNORED)."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'org-keyword-backend))
    (prefix (and (eq major-mode 'org-mode)
                 (cons (company-grab-line "^#\\+\\(\\w*\\)" 1)
                       t)))
    (candidates (mapcar #'upcase
                        (cl-remove-if-not
                         (lambda (c) (string-prefix-p arg c))
                         (pcomplete-completions))))
    (ignore-case t)
    (duplicates t)))
#+END_SRC
* Org-mode

** Core package

I use ~use-package~ to load ~org-mode~, but, to make it easier to annotate, I split other aspects of the configuration out into their own blocks.

Note that this is loaded /after/ ~citeproc-org~ because that has to add hooks before org-mode is loaded.
Otherwise, I have to manually reload Org to get ~citeproc-org~ to work.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure t
  :config
  (require 'ox-md))
#+END_SRC

** Agenda files

I keep my core org files backed up using Dropbox.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/Dropbox/Notes/" "~/Dropbox/references/notes.org"))
#+END_SRC

I have my core org-mode files organized as follows:
- unsorted.org :: Unsorted notes that automatically have the ~REFILE~ tag and show up in my custom agenda view. The goal is to keep this file empty.
- orgzly.org :: Similar to above, but limited to things I save from the "orgzly" app on my Android phone.
- work.org :: Notes related to work. This is broken down as follows:
              + Projects :: Manuscripts, proposals, etc. that I am working on
                            - Top-level headers for each projects, as well as...
                            - Project ideas :: Random, unstructured ideas for future projects. As these solidify, they should be moved into top-level headers.
              + Conferences :: Everything related to academic conferences, meetings, workshops, etc.
              + Job applications :: Notes related to past, present, and future job applications
              + Opportunities :: Possible places to work, research funding sources, etc.
              + Teaching :: Notes related to any kind of teaching
              + Work habits :: Work-related things I should be doing on a regular basis. Most important are reading literature and writing.
- computers.org :: Notes and tasks related to programming, software, etc. Small tasks related to "sharpening the knife" (e.g. tweaking configurations) are organized in here.
                   + Organization :: Default TODO for time logging. Also, notes related to how I am organized.
                   + R :: Things related to R programming.
                   + LaTeX :: Things related to writing in LaTeX, including beamer presentations
                   + Emacs :: Things related to my text editor, including configuration to-dos
                   + Unix :: Things related to Unix in general, including shells (bash, zsh), various utilities (awk, grep, ssh), and anything related to Linux configuration.
                   + Miscellaneous programming :: Other stuff related to programming
- life.org :: Notes and tasks that are not work-related, organized as follows:
              - Chores :: Chores that need to get done
              - Events :: Upcoming life/personal events
              - Music :: Things related to my music hobbies
              - Personal notes :: Random notes-to-self
              - Personal habits :: Non work-related things I should be doing regularly.

                   #+BEGIN_SRC emacs-lisp
(defun ans/clean-org-agenda-files ()
  "Remove org agenda files that don't exist."
  (interactive)
  (setq org-agenda-files (-filter 'file-exists-p (org-agenda-files))))

(ans/clean-org-agenda-files)

;; Custom source listing all agenda files
(defun ans/helm-org-agenda-list-files ()
  "Helm source listing all current org agenda files."
  (interactive)
  (helm :sources (helm-build-sync-source
                     "Org agenda files"
                   :candidates (org-agenda-files)
                   :action '(("Open file" . find-file)))
        :buffer "*helm agenda files*"))
                   #+END_SRC

** Agenda views

Exclude the following tags from inheritance.
This will make it easier to exclude top level headers from Agenda views.

#+BEGIN_SRC emacs-lisp
(setq org-tags-exclude-from-inheritance '("_project" "_organize"))
#+END_SRC

Toggle showing scheduled/deadline tasks in the default agenda view (by default, don't show these tasks).
This is nice because tasks scheduled for some point in the future shouldn't take up room in my to-do list.

#+BEGIN_SRC emacs-lisp
(setq ans/hide-scheduled-tasks t)
(setq org-agenda-tags-todo-honor-ignore-options t)

(defun ans/toggle-show-scheduled-tasks ()
  "Toggle display of scheduled/deadline tasks in agenda."
  (interactive)
  (setq ans/hide-scheduled-tasks (not ans/hide-scheduled-tasks))
  (when (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s SCHEDULED/DEADLINE tasks" (if ans/hide-scheduled-tasks "Hide" "Show")))
#+END_SRC

Define the custom agenda views.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '((" " "Agenda"
	 ((agenda "" nil)
	  (tags "REFILE"
		((org-agenda-overriding-header "Notes to Refile")
		 (org-tags-match-list-sublevels nil)))
	  (tags-todo "-REFILE-config-reading_list-_project-_organization/NEXT!"
		     ((org-agenda-overriding-header (concat "Next tasks"
							    (if ans/hide-scheduled-tasks
								""
							      " (including scheduled)")))
		      (org-agenda-todo-ignore-scheduled ans/hide-scheduled-tasks)
		      (org-agenda-sorting-strategy '(priority-down))))
	  (tags-todo "-REFILE-config-reading_list-_project-_organization/-NEXT!"
		     ((org-agenda-overriding-header (concat "Other tasks"
							    (if ans/hide-scheduled-tasks
								""
							      " (including scheduled)")))
		      (org-agenda-sorting-strategy '(todo-state-down priority-down))
		      (org-agenda-todo-ignore-deadlines ans/hide-scheduled-tasks))))
	 nil)
	("r" "Reading list" todo "TODO|NEXT"
	 ((org-agenda-files '("~/Dropbox/references/notes.org"))
	  (org-agenda-sorting-strategy '(todo-state-down priority-down))))
	("c" "Configuration" tags-todo "-_organization-_project"
	 ((org-agenda-files '("~/Dropbox/Notes/computers.org"))
	  (org-agenda-sorting-strategy '(todo-state-down priority-down))))
	("p" "Projects" tags-todo "_project"
	 ((org-agenda-sorting-strategy '(todo-state-down))))))
#+END_SRC

Some custom keybindings for org agenda mode.

#+BEGIN_SRC emacs-lisp
(general-def
  :states 'motion
  :keymaps 'org-agenda-mode-map
  "gl" 'org-agenda-log-mode
  "ga" 'ans/org-agenda-toggle-archive
  "gwd" 'org-agenda-day-view
  "gww" 'org-agenda-week-view
  "gwm" 'org-agenda-month-view
  "@" 'ans/toggle-show-scheduled-tasks)
#+END_SRC

This is the function for toggling display of archived entries in agenda.

#+BEGIN_SRC emacs-lisp
(defun ans/org-agenda-toggle-archive ()
  "Toggle showing archived entries in agenda mode."
  (interactive)
  (if org-agenda-archives-mode
      (progn (setq org-agenda-archives-mode nil)
             (message "Agenda archive mode disabled."))
    (setq org-agenda-archives-mode t)
    (message "Agenda archive mode enabled."))
  (org-agenda-redo))
#+END_SRC

Configure priorities.
The three priority levels are high (A, 65), normal (B, 66), and low (C, 67).
Tasks without a priority default to the normal (B) priority.
My agenda places higher-priority tasks at the top and lower-priority tasks at the bottom.

#+BEGIN_SRC emacs-lisp
(setq org-priority-start-cycle-with-default t
      org-default-priority 66
      org-highest-priority 65
      org-lowest-priority 67)
#+END_SRC

** Org capture

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("E" "Emacs config" entry
         (file+headline "~/Dropbox/Notes/computers.org" "TODO Emacs configuration")
         "** TODO %?" :clock-in t :clock-resume t)
        ("e" "Emacs note" entry
         (file+headline "~/Dropbox/Notes/computers.org" "Emacs")
         "** %?" :clock-in t :clock-resume t)
        ("t" "TODO" entry
         (file "~/Dropbox/Notes/unsorted.org")
         "* TODO %?\nCaptured %U\nFrom file %a\n" :clock-in t :clock-keep t)
        ("u" "Miscellaneous note" entry
         (file "~/Dropbox/Notes/unsorted.org")
         "* %? :NOTE:\nCaptured %U\n%a\n" :clock-in t :clock-resume t)
        ("i" "Interruption" entry (file "~/Dropbox/Notes/unsorted.org")
         "* %? \nCaptured %U" :clock-in t :clock-resume t)
        ("m" "Meeting" entry (file "~/Dropbox/Notes/unsorted.org")
         "* Meeting with %? \nCaptured %U" :clock-in t :clock-resume t)
        ("s" "Schedule event" entry (file "~/Dropbox/Notes/unsorted.org")
         "* %^{Event}t %? :NOTE:\nCaptured %U" :clock-in t :clock-resume t)))
#+END_SRC

*** org-capture-pop-frame

Run ~org-capture~ in its own frame.
This is temporarily disabled because it interferes with ~perspective~ in some edge cases.

#+BEGIN_SRC emacs-lisp
(use-package org-capture-pop-frame
  :disabled
  :ensure t)
#+END_SRC

** Default to-do keywords

All my org files have these to-do keywords by default.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "|" "DONE" "CANCELED")))
#+END_SRC

However, these can be set on a file-specific basis as well via the ~#+TODO~ property.

#+BEGIN_EXAMPLE
#+TODO: TODO FEEDBACK VERIFY | DONE CANCELLED
#+END_EXAMPLE

** Formatting and aesthetics

Show emphasis markers by default, but also quickly toggle them with a custom function.

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers nil)

(defun ans/org-toggle-emphasis-markers ()
  "Toggle the display of org emphasis markers."
  (interactive)
  (if org-hide-emphasis-markers
      (setq org-hide-emphasis-markers nil)
    (setq org-hide-emphasis-markers t))
  (font-lock-flush))
#+END_SRC

By default, hide line numbers in org-mode buffers, and disable adaptive prefix mode.

#+BEGIN_SRC emacs-lisp
(defun ans/org-mode-settings ()
  "Custom settings for org mode."
  (linum-mode -1)
  (adaptive-wrap-prefix-mode -1))

(add-hook 'org-mode-hook 'ans/org-mode-settings)
#+END_SRC

By default, use org-mode indentation.

#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
#+END_SRC

Automatically re-indent a source code block.

#+BEGIN_SRC emacs-lisp
(defun ans/indent-org-source-block ()
  "Re-indent an org mode source code block."
  (interactive)
  (when (org-in-src-block-p)
    (org-edit-special)
    (indent-region (point-min) (point-max))
    (org-edit-src-exit)))
#+END_SRC

Don't reposition the screen when expanding an outline.
Note that the cursor can be repositioned at the center of the screen with =zz=.

#+BEGIN_SRC emacs-lisp
(remove-hook 'org-cycle-hook #'org-optimize-window-after-visibility-change)
#+END_SRC

End of line should ignore tags.

#+BEGIN_SRC emacs-lisp
(setq org-special-ctrl-a/e t)
#+END_SRC

** Source code (babel)

Automatically fontify source code, and edit source code in the current window (rather than opening a new one).

#+BEGIN_SRC emacs-lisp
(setq org-babel-load-languages '((emacs-lisp . t) (R . t))
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-window-setup 'other-window
      org-src-preserve-indentation t)

(set-face-attribute 'org-block nil :foreground nil :background "Gray15")
(set-face-attribute 'org-block-begin-line nil :background "#001436")

(condition-case ans/babel-error
    (with-eval-after-load 'org
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t) (R . t))))
  ((debug error) (message "Failed with error %s" ans/babel-error)))
#+END_SRC

Don't prompt for confirmation on babel evaluation.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

Set some language-specific default settings.

#+BEGIN_SRC emacs-lisp
(defvar org-babel-default-header-args:R '((:session . "*org-R*")))
#+END_SRC

** Refile

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9))
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm
      org-refile-target-verify-function 'ans/verify-refile-target)

(defun ans/verify-refile-target ()
  "Exclude TODO keywords with a done state from refile targets."
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
#+END_SRC

** Clocking

Use the clocking settings from "Organize your life in plain text".

#+BEGIN_SRC emacs-lisp
(setq
 ;; Resume clocking task on clock in if it's already open
 org-clock-in-resume t
 ;; Separate drawers for clocking and logs
 org-drawers '("PROPERTIES" "LOGBOOK")
 ;; Save clock data and state changes and notes in LOGBOOK drawer
 org-clock-into-drawer t
 ;; Remove clocks with 0:00 duration
 org-clock-out-remove-zero-time-clocks t
 ;; Clock out when marking a task as DONE
 org-clock-out-when-done t
 ;; Save running clock and clock history when exiting emacs; reload on startup
 ;; See org-clock-persistence-insinuate below
 org-clock-persist t
 ;; Do not prompt to resume an active clock
 org-clock-persist-query-resume nil
 ;; Auto-clock resolution for finding open clocks
 org-clock-auto-clock-resolution (quote when-no-clock-is-running)
 ;; Include current clocking task in clock reports
 org-clock-report-include-clocking-task t
 ;; Show current clock time in frame title
 org-clock-mode-line-total 'current
 org-clock-clocked-in-display 'frame-title)

(org-clock-persistence-insinuate)
#+END_SRC

When clocking out of a task, automatically clock into the parent task

#+BEGIN_SRC emacs-lisp
(defun ans/clock-out-maybe ()
  "Clock parent task, or clock out."
  (when (and ans/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (ans/clock-in-parent-task)))

(defun ans/clock-in-parent-task ()
  "Move point to parent task (if any) and clock in.
  Otherwise, clock in the default task."
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when ans/keep-clock-running
            (ans/clock-in-organization-task)))))))

(add-hook 'org-clock-out-hook #'ans/clock-out-maybe 'append)
#+END_SRC

Default settings for a clocktable.

#+BEGIN_SRC emacs-lisp
(setq org-clock-clocktable-default-properties
      '(:maxlevel 5 :scope agenda-with-archives :block today :link t)
      org-agenda-clockreport-parameter-plist
      '(:maxlevel 5 :link t))
#+END_SRC

*** Clocking functions

Clock into a default task ("organization").

#+BEGIN_SRC emacs-lisp
(defun ans/punch-in ()
  "Start clocking, and set default task to Organization."
  (interactive)
  (setq ans/keep-clock-running t)
  (ans/clock-in-organization-task))

(defun ans/punch-out ()
  "End all clocking."
  (interactive)
  (setq ans/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Default clocking task ("organization") ID
(defvar ans/organization-task-id "b86713a1-f9db-47c5-860f-6a2aecfec6c9")
(defun ans/clock-in-organization-task ()
  "Clock in the default organization task."
  (interactive)
  (org-with-point-at (org-id-find ans/organization-task-id 'marker)
    (org-clock-in '(16))))
#+END_SRC

** Custom structure templates

These are expanded by typing ~<~ followed by the character(s) and then ~TAB~.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist
             '("p" ":PROPERTIES:\n?\n:END:"))
#+END_SRC

** Org-mode keybindings

#+BEGIN_SRC emacs-lisp
(general-def
  :states '(normal insert)
  :keymaps 'org-mode-map
  "C-c C-q" 'org-set-tags
  "M-l" 'org-metaright
  "M-S-l" 'org-demote-subtree
  "M-h" 'org-metaleft
  "M-S-l" 'org-promote-subtree
  "<C-M-return>" 'org-insert-subheading)

(general-def
  :states '(motion normal)
  :keymaps 'org-mode-map
  "<backspace>" 'outline-hide-subtree
  "gh" 'org-up-element
  "gl" 'org-down-element
  "gt" 'org-todo
  "g$" 'evil-end-of-line
  "g%" 'ans/org-realign-tags
  "go" 'ans/evil-insert-heading-after-current
  "gO" 'ans/evil-insert-heading)

(general-def
  :states 'visual
  :keymaps 'org-mode-map
  :prefix "\\"
  "ss" 'eval-region)

(general-def
  :states 'normal
  :keymaps 'org-mode-map
  :prefix "\\"
  "e" 'org-edit-special
  "k" 'org-export-dispatch
  "RET" 'org-ctrl-c-ctrl-c
  "=" 'ans/indent-org-source-block
  "TAB" 'ans/org-hide-all-except-current)

(general-def
  :states 'insert
  :keymaps 'org-mode-map
  "C-=" '(lambda () (interactive)(insert "#+"))
  "C-/" 'org-toggle-checkbox
  "C--" 'org-toggle-item
  "C-." 'org-cycle-list-bullet
  "C-," '(lambda () (interactive) (org-cycle-list-bullet 'previous)))

(general-def
  :states '(motion normal emacs)
  :keymaps 'org-mode-map
  :prefix "SPC"
  "#" 'org-update-statistics-cookies
  "%" 'ans/org-toggle-emphasis-markers)

(general-def
  :states '(motion normal visual)
  :keymaps 'org-mode-map
  :prefix "SPC"
  "ss" 'org-schedule
  "sd" 'org-deadline)

(general-def
  :states '(motion)
  :keymaps 'calendar-mode-map
  "h" 'calendar-backward-day
  "l" 'calendar-forward-day
  "k" 'calendar-backward-week
  "j" 'calendar-forward-week
  "H" 'calendar-backward-month
  "L" 'calendar-forward-month)
#+END_SRC

*** evil-org

#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :ensure t
  :after org
  :config
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook 'ans/evil-org-mode-setup)
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))

(defun ans/evil-org-mode-setup ()
  "Custom setup for org mode."
  (push '(?* . ("*" . "*")) evil-surround-pairs-alist)
  (push '(?/ . ("/" . "/")) evil-surround-pairs-alist)
  (evil-org-set-key-theme '(navigation insert textobjects calendar)))
#+END_SRC

** Other custom functions

#+BEGIN_SRC emacs-lisp
(defun ans/evil-insert-heading ()
  "Insert heading before point and enter insert mode."
  (interactive)
  (org-insert-heading)
  (evil-insert 1))

(defun ans/evil-insert-heading-after-current ()
  "Insert heading after point and enter insert mode."
  (interactive)
  (org-insert-heading-respect-content)
  (evil-insert 1))

(defun ans/org-realign-tags ()
  "Right-align org mode tags in current buffer."
  (interactive)
  (org-set-tags nil t))

(defun air--org-swap-tags (tags)
  "Replace any tags on the current headline with TAGS.

  The assumption is that TAGS will be a string conforming to Org Mode's
  tag format specifications, or nil to remove all tags."
  (let ((old-tags (org-get-tags-string))
        (tags (if tags
                  (concat " " tags)
                "")))
    (save-excursion
      (beginning-of-line)
      (re-search-forward
       (concat "[ \t]*" (regexp-quote old-tags) "[ \t]*$")
       (line-end-position) t)
      (replace-match tags)
      (org-set-tags t))))

(defun air-org-set-tags (tag)
  "Add TAG if it is not in the list of tags, remove it otherwise.

  TAG is chosen interactively from the global tags completion table."
  (interactive
   (list (let ((org-last-tags-completion-table
                (if (derived-mode-p 'org-mode)
                    (org-uniquify
                     (delq nil (append (org-get-buffer-tags)
                                       (org-global-tags-completion-table))))
                  (org-global-tags-completion-table))))
           (completing-read
            "Tag: " 'org-tags-completion-function nil nil nil
            'org-tags-history))))
  (let* ((cur-list (org-get-tags))
         (new-tags (mapconcat 'identity
                              (if (member tag cur-list)
                                  (delete tag cur-list)
                                (append cur-list (list tag)))
                              ":"))
         (new (if (> (length new-tags) 1) (concat " :" new-tags ":")
                nil)))
    (air--org-swap-tags new)))

(defun ans/org-hide-all-except-current ()
  "Close all subtrees outside of the current view."
  (interactive)
  (save-excursion
    (org-global-cycle))
  (org-cycle))

(defun ans/org-agenda-mode-p ()
  "Boolean to check if currently in agenda mode."
  (equal major-mode 'org-agenda-mode))
#+END_SRC

** org-journal

#+BEGIN_SRC emacs-lisp
(use-package org-journal
  :ensure t
  :init
  (setq org-journal-dir "~/Dropbox/Notes/journal"
        org-journal-file-format "%Y-%m-%d"
        org-journal-enable-agenda-integration t))
(evil-ex-define-cmd "now" 'org-journal-new-entry)
#+END_SRC
** toc-org

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :ensure t
  :config
  (add-hook 'org-mode-hook 'toc-org-enable))
#+END_SRC
** org-ref

#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :ensure t
  :init
  (setq org-ref-bibliography-notes ans/reference-notes
        reftex-default-bibliography `(,ans/reference-bibfile)
        org-ref-default-bibliography `(,ans/reference-bibfile)
        org-ref-pdf-directory ans/reference-dir-pdfs
        org-ref-bibtex-hydra-key-binding nil
        org-ref-note-title-format
        "** TODO %2a %y - %T
:PROPERTIES:
:Custom_ID: %k
:AUTHOR: %9a
:FULL_TITLE: %t
:JOURNAL: %j
:YEAR: %y
:VOLUME: %v
:PAGES: %p
:DOI: %D
:URL: %U
:END:
")
  (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
  :general
  (general-def
    :states 'normal
    "\\\\" 'org-ref-bibtex-hydra/body)
  (general-def
    :states 'insert
    "C-\\" 'org-ref-bibtex-hydra/body)
  (general-def
    :keymaps 'org-ref-bibtex-hydra/keymap
    "n" '(lambda ()(interactive) (org-ref-open-bibtex-notes) (hydra-keyboard-quit))))
#+END_SRC
** citeproc-org

Note that this is lazily loaded when ~citeproc-org-setup~ is called.
Note also that loading this package triggers ~org-reload~.

#+BEGIN_SRC emacs-lisp
(use-package citeproc-org
  :quelpa (citeproc-org :fetcher github :repo "andras-simonyi/citeproc-org")
  :commands citeproc-org-setup
  :init
  (setq citeproc-org-ignore-backends nil)
  :config
  (citeproc-org-setup)
  (org-reload))
#+END_SRC
** Hydras for org mode tasks

*** Main org-mode hydra

#+BEGIN_SRC emacs-lisp
(defhydra ans/org-mode-hydra (:exit t)
  "Org mode"
  ("a" org-agenda "Agenda")
  ("o" org-capture "Capture")
  ("r" ans/org-refile-aware "Refile")
  ("s" helm-org-rifle-agenda-files "Search")
  ("/" helm-org-rifle-current-buffer "Search current")
  ("f" ans/helm-org-agenda-list-files "List agenda files")
  ("l" org-store-link "Store link")
  ("L" org-insert-last-stored-link "Insert stored link")
  ("n" ans/org-toggle-narrow "Toggle narrow")
  ("N" org-narrow-to-subtree "Narrow")
  ("0" widen "Widen")
  ("e" org-edit-special "Edit special")
  ("E" org-export-dispatch "Export")
  ("c" ans/clock-hydra/body "Clocking")
  ("t" ans/org-scheduling-hydra/body "Scheduling")
  ("b" ans/org-babel-hydra/body "Babel")
  ("S" org-save-all-org-buffers "Save all buffers")
  ("x" ans/make-org-scratch "Open scratch")
  ("DEL" org-archive-subtree-default "Archive")
  ("!" org-reload "Reload")
  ("&" org-toggle-pretty-entities "Toggle pretty math")
  ("SPC" org-ctrl-c-ctrl-c "C-c"))

(defun ans/org-refile-aware ()
  "Context-aware org refile."
  (interactive)
  (cond ((ans/org-agenda-mode-p) (org-agenda-refile))
	((bound-and-true-p org-capture-mode) (org-capture-refile))
	(t (org-refile))))

(defun ans/org-toggle-narrow ()
  "Narrow if widened, otherwise widen."
  (interactive)
  (if (buffer-narrowed-p)
      (widen)
    (org-narrow-to-subtree)))

(defun ans/make-org-scratch ()
  "Open an org-mode scratch buffer."
  (interactive)
  (find-file "/tmp/publish/scratch.org")
  (gnus-make-directory "/tmp/publish"))
#+END_SRC

*** Hydra for clocking

#+BEGIN_SRC emacs-lisp
(defhydra ans/clock-hydra (:exit t)
  "Clocking commands."
  ("RET" org-clock-in "Clock in")
  ("<backspace>" org-clock-out "Clock out")
  ("+" ans/punch-in "Punch in")
  ("-" ans/punch-out "Punch out")
  ("g" org-clock-goto "Go to current clock")
  ("l" org-clock-in-last "Go to most recent clock")
  ("h" (org-clock-in-last '(4)) "Clock from history")
  ("r" org-clock-report "Insert clock report"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defhydra ans/org-scheduling-hydra (:exit t)
  "Deadlines and scheduling."
  ("d" ans/org-deadline-aware "Deadline")
  ("s" ans/org-schedule-aware "Schedule"))

(defun ans/org-deadline-aware (arg)
  "Context-aware org-deadline."
  (interactive "P")
  (if (ans/org-agenda-mode-p)
      (call-interactively 'org-agenda-deadline)
    (org-deadline arg)))

(defun ans/org-schedule-aware (arg)
  "Context-aware org-schedule."
  (interactive "P")
  (if (ans/org-agenda-mode-p)
      (call-interactively 'org-agenda-schedule)
    (org-schedule arg)))
#+END_SRC

*** Hydra for org-babel

#+BEGIN_SRC emacs-lisp
(defhydra ans/org-babel-hydra (:exit t)
  "org-babel"
  ("t" org-babel-tangle "tangle")
  ("T" org-table-export "export table")
  ("-" org-babel-demarcate-block "split block")
  ("r" org-babel-execute-subtree "run subtree")
  ("R" org-babel-execute-buffer "run buffer")
  ("g" org-babel-goto-named-src-block "goto block")
  ("G" org-babel-goto-named-result "goto result")
  ("SPC" org-babel-goto-src-block-head "block head")
  ("F" org-babel-tangle-jump-to-org "jump to org file")
  ("s" org-babel-switch-to-session "session")
  ("S" org-babel-switch-to-session-with-code "session with code"))
#+END_SRC

** Github-flavored markdown

#+BEGIN_SRC emacs-lisp
(use-package ox-gfm
  :ensure t
  :after org)
#+END_SRC

** Habits

Load the habits module.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-modules 'org-habit)
#+END_SRC

For now, don't show habits in the agenda view.
I still need to set this up.

#+BEGIN_SRC emacs-lisp
(setq org-habit-show-habits nil)
#+END_SRC

** Convert org-mode table to format in place

Instead of creating a new file, just replace the current table.
Sourced from [[https://gist.github.com/ShingoFukuyama/7887053][this GitHub gist]].

#+BEGIN_SRC emacs-lisp
(defun ans/get-string-from-file (file-path)
  "Return contents of FILE-PATH as a string."
  (with-temp-buffer
    (insert-file-contents file-path)
    (buffer-string)))

(defun ans/org-table-convert-replace ()
  "Convert org table to CSV in place"
  (interactive)
  (unless (org-at-table-p) (user-error "No table at point"))
  (let* ((target-file (make-temp-file "orgtbl"))
	 (beg (org-table-begin))
	 (end (org-table-end)))
    (org-table-export target-file "orgtbl-to-csv")
    (delete-region beg end)
    (insert-file-contents target-file)))
#+END_SRC

** Remove headlines but keep content

Use org mode outline for organization, but hide this organization from exported documents.

#+BEGIN_SRC emacs-lisp
(defun ans/org-remove-headlines (backend)
  "Remove headlines with :no_title tag."
  (org-map-entries (lambda () (delete-region (point-at-bol) (point-at-eol)))
		   "no_title"))

(add-hook 'org-export-before-processing-hook #'ans/org-remove-headlines)
#+END_SRC
* yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (setq yas-snippet-dirs '("~/.emacs.d/snippets")
	yas-visit-from-menu t)
  :config
  (yas-reload-all)
  (yas-global-mode 1)
  ;; Use something like this if you don't want snippets globally:
  ;; (yas-reload-all)
  ;; (add-hook 'prog-mode-hook #'yas-minor-mode)
  (general-def
    :keymaps 'yas-minor-mode-map
    "<escape>" 'yas-exit-snippet)
  (ans-leader-def
    :states '(motion normal)
    "un" 'yas-new-snippet
    "ue" 'yas-visit-snippet-file
    "ur" 'yas-reload-all))
#+END_SRC
* ESS -- Emacs Speaks Statistics

** ESS core configuration

#+BEGIN_SRC emacs-lisp
(use-package ess
  :ensure t
  :mode ("\\.[rR]\\'" . r-mode)
  :config
  (require 'ess-rutils)
  (setq comint-move-point-for-output t)	; Scroll R buffer on output
  (setq ess-ask-for-ess-directory nil
        ess-directory-function 'ans-r-file-here
        ess-default-style 'RStudio
        ess-use-company t
        ess-eval-visibly 'nowait)
  (setq ess-roxy-str "#'"
	ess-roxy-fill-param-p t
	ess-roxy-template-alist
	'(("description" . ".. title/description ..")
	  ("param" . "")
	  ("return" . "")
	  ("author" . "Alexey Shiklomanov")))
  (add-to-list 'ess-R-font-lock-keywords
               '(ess-fl-keyword:fun-calls . t) t)
  (ans/add-evil-maps 'ess-help-mode-map)
  ;; Temporarily disable because of bug
  ;; See emacs-ess/ESS issue #720
  (setq ess-use-tracebug nil)
  :config
  (general-def
    :keymaps 'ess-mode-map
    :states 'normal
    :prefix "\\"
    "r f" 'ans-start-R
    "r q" 'ans-quit-R
    "l" 'ess-eval-line
    "d" 'ess-eval-line-and-step
    "f f" 'ess-eval-function
    "p p" 'ess-eval-paragraph
    "p d" 'ess-eval-paragraph-and-step
    "a a" 'ess-eval-buffer
    "a d" 'ess-eval-buffer-from-here-to-end
    "a s" 'ess-eval-buffer-from-beg-to-here
    "v i" 'ess-r-devtools-install-package
    "v d" 'ess-r-devtools-document-package
    "v l" 'ess-r-devtools-load-package
    "v t" 'ess-r-devtools-test-package
    "r h" 'ess-display-help-on-object
    "r o" 'ess-rutils-objs
    "r p" 'ans/ess-eval-symbol
    "r g" 'ans/ess-glimpse-symbol
    "r s" 'ans/ess-symbol-size
    "k r" 'ans/rmarkdown-render
    "x " 'ess-interrupt
    "o p" 'ans/ess-plot-symbol-scatter
    "o l" 'ans/ess-plot-symbol-line
    "O p" 'ans/ess-matplot-symbol-points
    "O l" 'ans/ess-matplot-symbol-lines)
  (general-def
    :keymaps 'ess-mode-map
    "M-RET" 'ess-newline-and-indent)
  (general-def
    :states 'visual
    :keymaps 'ess-mode-map
    :prefix "\\"
    "s s" 'ess-eval-region
    "r x" 'ans/ess-reprex-region)
  (general-def
    :states 'insert
    :keymaps 'inferior-ess-mode-map
    "_" 'self-insert-command
    "M--" 'ess-insert-S-assign)
  (general-def
    :states 'insert
    :keymaps 'ess-mode-map
    "_" 'self-insert-command
    "M-m" (lambda() (interactive)(insert " %>%"))
    "M--" 'ess-insert-S-assign
    "C-c" (lambda() (interactive)(insert "#'"))
    "C-8" (lambda() (interactive)(insert " %*% ")))
  (general-def
    :keymaps 'ess-help-mode-map
    :states 'emacs
    "SPC" 'ans-leader-command)
  (general-def
    :keymaps 'ess-help-mode-map
    :states 'emacs
    :prefix "\\"
    "r h" 'ess-display-help-on-object)
  (general-def
    :keymaps 'ess-rdired-mode-map
    "j" 'ess-rdired-next-line
    "k" 'ess-rdired-previous-line))

(defun ans/inferior-ess-mode-setup ()
  "My custom configuration for inferior-ess-mode."
  (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions)))

(add-hook 'inferior-ess-mode-hook 'ans/inferior-ess-mode-setup)
#+END_SRC

** Custom functions

*** Eval current symbol

#+BEGIN_SRC emacs-lisp
(defun ans/ess-eval-symbol ()
  "Evaluate (usually print) the symbol at point."
  (interactive)
  (save-excursion
    (er/mark-symbol)
    (ess-eval-region (point) (mark) nil)
    (deactivate-mark)))
#+END_SRC

*** ~dplyr::glimpse~

#+BEGIN_SRC emacs-lisp
(defun ans/ess-glimpse-symbol ()
  "Run 'dplyr::glimpse' on symbol at point."
  (interactive)
  (ess-send-string (ess-get-process) (format "dplyr::glimpse(%s)" (symbol-at-point))))
#+END_SRC

*** ~reprex::reprex~

#+BEGIN_SRC emacs-lisp
(defun ans/ess-reprex-region (start end venue)
  "Run the selection through `reprex::reprex', saving the output to the clipboard."
  (interactive "r\nsVenue (gh, so, ds, or r): ")
  (ess-send-string
   (ess-get-process)
   (format "reprex::reprex({%s}, venue = '%s', show = FALSE, advertise = FALSE)"
	   (buffer-substring-no-properties start end)
	   venue)))
#+END_SRC

*** ~Rcpp::compileAttributes()~

#+BEGIN_SRC emacs-lisp
(defun ans/ess-compile-attributes ()
  "Run ~Rcpp::compileAttributes~ on the package in the current directory."
  (interactive)
  (ess-send-string
   (ess-get-process)
   "Rcpp::compileAttributes()"))
#+END_SRC

*** Plot and matplot

#+BEGIN_SRC emacs-lisp
(defun ans/ess-plot-symbol-scatter ()
  "Do a base R scatter plot on the symbol at point."
  (interactive)
  (ess-send-string
   (ess-get-process)
   (format "plot(%s)" (symbol-at-point))))

(defun ans/ess-plot-symbol-line ()
  "Do a base R plot on the symbol at point."
  (interactive)
  (ess-send-string
   (ess-get-process)
   (format "plot(%s, type = 'l')" (symbol-at-point))))

(defun ans/ess-matplot-symbol-points ()
  "Do a matrix plot on the symbol at point."
  (interactive)
  (ess-send-string
   (ess-get-process)
   (format "matplot(%s)" (symbol-at-point))))

(defun ans/ess-matplot-symbol-lines ()
  "Do a matrix plot on the symbol at point."
  (interactive)
  (ess-send-string
   (ess-get-process)
   (format "matplot(%s, type = 'l')" (symbol-at-point))))
#+END_SRC
*** Size of symbol at point

#+BEGIN_SRC emacs-lisp
(defun ans/ess-symbol-size ()
  "Run 'pryr::object_size' on symbol at point."
  (interactive)
  (ess-send-string (ess-get-process) (format "pryr::object_size(%s)" (symbol-at-point))))
#+END_SRC
*** Other
#+BEGIN_SRC emacs-lisp
(defun ans/rmarkdown-render ()
  "Render the current R markdown document."
  (interactive)
  (ess-send-string (ess-get-process) (format "rmarkdown::render('%s')" (buffer-file-name))))

(defun ans-split-right-if-wide ()
  "Split the window to the right if there is sufficient space."
  (interactive)
  (if (< (window-total-width) 140)
      (split-window-below)
    (split-window-right (* -4 (/ (window-total-width) 9)))))

(defun ans-r-file-here ()
  "Use here::here to determine path for R buffer."
  (shell-command-to-string
   (concat
    "/usr/local/bin/Rscript -e \""
    "my_dir <- dirname('"(buffer-file-name)"');"
    "t <- tryCatch(setwd(my_dir), error = function(e) NULL);"
    "cat(here::here())"
    "\"")))

(defun ans-start-R ()
  "Start R with default options, splitting the window vertically."
  (interactive)
  (ans-split-right-if-wide)
  (save-selected-window
    (other-window 1)
    (R "--no-save --no-restore")))

(defun ans-quit-R ()
  "Quit R process and close buffer."
  (interactive)
  (ess-quit)
  (kill-buffer)
  (delete-window))
#+END_SRC

** ox-ravel

#+BEGIN_SRC emacs-lisp :tangle no
;; ox-ravel -- Better R integration into org mode
(require 'ox-ravel)
#+END_SRC

** Custom imports functions (WIP)
:PROPERTIES:
:header-args: :tangle no :eval no
:END:

Parse, and quickly add to, ~import::from(package, function, ...)~ lists.
This was a nice opportunity to play with some more serious Lisp coding.

The general idea is that a script or function will have an imports list that looks something like:

#+BEGIN_SRC R
# begin imports
import::from(dplyr, select, mutate, bind_rows, .into = "")
import::from(tidyr, gather, spread, .into = "")
# end imports
#+END_SRC

My function searches for ~begin imports/end imports~, then converts them lists where the first element is the package and every subsequent element is a function.
The objective is to get a system where, with the point over ~package::function~, I run an interactive function ~ans/imports/add-to-imports~, which will check if the package-function combination is in the imports, and if not, add it intelligently.

This code makes extensive use of the [[https://github.com/magnars/s.el][s.el]] (string manipulation) and [[https://github.com/magnars/dash.el][dash.el]] (list manipulation) libraries.

#+BEGIN_SRC emacs-lisp
;; dplyr::select
;; dplyr::bind_rows
;; tidyr::gather
;;
;; # begin imports
;; import::from(dplyr, select, mutate, bind_rows, .into = "")
;; import::from(tidyr, gather, spread, .into = "")
;; # end imports

(defun ans/import/R-pkg-fun-word-at-point ()
  "Select a package::function statement as a word."
  (let (($temp-syn-table (make-syntax-table ess-r-syntax-table)))
    (modify-syntax-entry ?: "w" $temp-syn-table)
    (modify-syntax-entry ?_ "w" $temp-syn-table)
    (with-syntax-table $temp-syn-table
      (word-at-point))))

(defun ans/import/split-pkg-fun-call (word)
  "Split WORD containing package::function into package and function."
  (s-split "::" word))

(defun ans/import/import-to-list (import-string)
  "Grab IMPORT-STRING and convert to a list.

  The first element of this list is the package and the remaining statements are imports."
  (let ((import-list (s-with import-string
                       (s-chop-prefix "import::from(")
                       (s-chop-suffix ")")
                       (s-split ", +"))))
    (-remove (lambda (s) (s-matches? "\.into +=" s)) import-list)))

(defun ans/import/find-import-lists ()
  "Find the nearest imports list from the current buffer, and return
    their start and end points as a list.

  Imports lists start with the comment string 'begin imports' and end
  with 'end imports'."
  (let* ((import-start (save-excursion
                         (re-search-backward "#+ *begin imports" nil t)
                         (forward-line)
                         (point)))
         (import-end (save-excursion
                       (goto-char import-start)
                       (re-search-forward "#+ *end imports" nil t)
                       (forward-line -1)
                       (end-of-line)
                       (point))))
    (when (and import-start import-end)
      (list import-start import-end))))

(defun ans/import/parse-import-lists (import-block-string)
  "Convert block of import statements into a list of import strings.

  In the process, remove extraneous whitespace."
  (let* ((import-block-list
          (s-with import-block-string
            (s-collapse-whitespace)
            (s-match-strings-all "import::from(.*?)"))))
    (-map 'ans/import/import-to-list (-flatten import-block-list))))

(defun ans/import/read-imports ()
  "Read and parse current buffer's imports block."
  (let* ((import-start-end (ans/import/find-import-lists))
         (import-block (buffer-substring-no-properties
                        (nth 0 import-start-end)
                        (nth 1 import-start-end))))
    (ans/import/parse-import-lists import-block)))

(defun ans/import/list-to-import (import-list)
  "Convert import-list to a formatted import string."
  (let* ((imports-joined (s-join ", " import-list)))
    (s-with imports-joined (s-prepend "import::from(") (s-append ", .into = \"\")"))))

(defun ans/import/replace-imports (import-start-end new-imports)
  "Replace imports list at IMPORT-START-END with NEW-IMPORTS."
  (delete-region (nth 0 import-start-end) (nth 1 import-start-end))
  (let* ((import-string-list (-map 'ans/import/list-to-import new-imports))
         (import-string (s-join "\n" import-string-list)))
    (save-excursion
      (goto-char (nth 0 import-start-end))
      (insert import-string))))

(defun ans/import/add-to-imports ()
  "Add the current thing to the imports list and update the imports list."
  (interactive)
  (let* ((addition (ans/import/split-pkg-fun-call (ans/import/R-pkg-fun-word-at-point))))
    (when (= (length addition) 2)
      (let ((current-imports (ans/import/read-imports)))
        (if (= (length current-imports) 0)
            (ans/import/replace-imports (ans/import/find-import-lists) addition)
          ;; WORK IN PROGRESS...
          (let ((current-packages ))))))))

;; Workflow
;; - Read current pkg::function form into list ADDITION
;; - Read current imports list into list IMPORTS
;; - Extract first elements of IMPORTS into PACKAGES
;; - (if (-contains? PACKAGES (nth 0 ADDITION))...
;;   - let (NEW-FUNCTION (nth 1 ADDITION))
;;   - let (ADD-TO-PACKAGE (which PACKAGES == PACKAGES))
;;   - let (FUNCTIONS (nthcdr 1 (nth ADD-TO-PACKAGE PACKAGES)))
;;   - If (NEW-FUNCTION not in FUNCTIONS)
;;     - (-update-at (ADD-TO-PACKAGE) (nth ADD-TO-PACKAGE IMPORTS) (append (nth 1 ADDITION)))
;;   - ...)
#+END_SRC

* LaTeX
** LaTeX core configuration

#+BEGIN_SRC emacs-lisp
(use-package tex
  :defer t
  :ensure auctex
  :mode ("\\.tex\\'" . LaTeX-mode)
  :init
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t)
  :config
  (add-hook 'LaTeX-mode-hook 'ans-latex-mode-setup)
  (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook #'TeX-revert-document-buffer))

(defun ans-latex-mode-setup ()
  "Set custom options for LaTeX files."
  (require 'reftex)
  ;; Use settings for text mode
  (ans-text-mode-setup)
  ;; Use the "default" vim paragraph definition
  (setq paragraph-start "\f\\|[ 	]*$")
  (setq paragraph-separate "[ 	\f]*$"))
#+END_SRC
** auctex-latexmk

#+BEGIN_SRC emacs-lisp
(use-package auctex-latexmk
  :ensure t
  :after tex
  :init
  (setq auctex-latexmk-inherit-TeX-PDF-mode t)
  :config
  (auctex-latexmk-setup))
#+END_SRC
** helm-bibtex

#+BEGIN_SRC emacs-lisp
(use-package helm-bibtex
  :ensure t
  :after org-ref
  :init
  (setq bibtex-completion-bibliography ans/reference-bibfile
        bibtex-completion-library-path ans/reference-dir-pdfs
        bibtex-completion-notes-path ans/reference-notes
        bibtex-autokey-name-case-convert-function 'downcase
        bibtex-autokey-name-year-separator "_"
        bibtex-autokey-year-title-separator "_"
        bibtex-autokey-year-length 4
        bibtex-autokey-titlewords 1
        bibtex-autokey-titleword-length nil
        bibtex-autokey-titleword-case-convert-function 'downcase)
  (setq bibtex-completion-notes-template-one-file
"** TODO ${author-abbrev} (${year}): ${title}
:PROPERTIES:
:Custom_ID: ${=key=}
:AUTHOR: ${author-or-editor}
:FULL_TITLE: ${title}
:JOURNAL: ${journal}
:YEAR: ${year}
:VOLUME: ${volume}
:PAGES: ${pages}
:DOI: ${doi}
:URL: ${url}
:END:
cite:${=key=}
")
  :commands (helm-bibtex)
  :config
  (helm-delete-action-from-source "Edit notes" helm-source-bibtex)
  (helm-add-action-to-source "Edit notes" 'ans/org-ref-notes-function helm-source-bibtex 7)
  (defun bibtex-completion-fallback-candidates ()
    "Custom list of bibtex fallback options. This is the same as the
one that ships with helm-bibtex, except that
`bibtex-completion-fallback-options` comes first."
    (let ((bib-files (bibtex-completion-normalize-bibliography 'main)))
      (-concat
       bibtex-completion-fallback-options
       (--map (cons (s-concat "Create new entry in " (f-filename it))
                    `(lambda (_search-expression) (find-file ,it) (goto-char (point-max)) (newline)))
              bib-files))))
  (evil-ex-define-cmd "bib[tex]" 'helm-bibtex)
  (general-def
    :states 'emacs
    :keymaps 'biblio-selection-mode-map
    "I" 'ans/biblio-selection-insert-end-of-bibfile))
#+END_SRC

Custom function to insert bibtex entry at the end of my ~library.bib~ file.

#+BEGIN_SRC emacs-lisp
(defun ans/biblio--selection-insert-at-end-of-bibfile-callback (bibtex entry)
  "Add BIBTEX (from ENTRY) to end of library.bib file."
  (with-current-buffer (find-file-noselect ans/reference-bibfile)
    (goto-char (point-max))
    (insert bibtex)
    (org-ref-clean-bibtex-entry)
    (save-buffer))
  (message "Inserted bibtex entry for %S."
           (biblio--prepare-title (biblio-alist-get 'title entry))))

(defun ans/biblio-selection-insert-end-of-bibfile ()
  "Insert BibTeX of current entry at the end of my library.bib file."
  (interactive)
  (biblio--selection-forward-bibtex #'ans/biblio--selection-insert-at-end-of-bibfile-callback))
#+END_SRC

When automatically creating a bibtex key, replace non-ASCII characters to avoid invalid key errors.

#+BEGIN_SRC emacs-lisp
(defun ans/asciify-string (string)
  "Use iconv to convert non-ASCII characters in STRING to ASCII equivalents."
  (with-temp-buffer
    (insert string)
    (call-process-region (point-min) (point-max)
                         "iconv" t t nil "--to-code=ASCII//TRANSLIT")
    (let* 
        ((result (buffer-substring-no-properties (point-min) (point-max)))
         (result (replace-regexp-in-string "[^[:alnum:][:blank:]_-]" "" result)))
      result)))

(defun ans/custom-org-clean-function (key)
  "Remove special characters from Bibtex key."
  (replace-regexp-in-string ":" "" key)
  (ans/asciify-string key))

(setq org-ref-clean-bibtex-key-function 'ans/custom-org-clean-function)
#+END_SRC

** ebib

In general, [[helm-bibtex][helm-bibtex]] and [[org-ref]] provide a pretty solid interface for working with references.
However, it's nice to have a more sophisticated solution for organizing a bibtex file.
Ebib provides a nice, Zotero-like interface to bib files that is easier to work with than the raw bibfiles.
Here, I tell Ebib to grab my default, global library, and modify its default keybindings with more evil-friendly ones.

#+BEGIN_SRC emacs-lisp
(use-package ebib
  :ensure t
  :commands ebib
  :init
  (add-to-list 'evil-emacs-state-modes 'ebib-index-mode)
  (setq ebib-preload-bib-files '("~/Dropbox/references/library.bib"))
  :config
  (general-def
    :keymaps 'ebib-index-mode-map
    :states 'emacs
    "j" 'ebib-next-entry
    "k" 'ebib-prev-entry
    "d" 'ebib-kill-entry
    "p" 'ebib-yank-entry
    "SPC" ans-leader-map))
#+END_SRC
* Editing tools
** rebox2

Edit comment boxes.

#+BEGIN_SRC emacs-lisp
(use-package rebox2
  :ensure t
  :general
  (general-def
    :states 'normal
    "gR" 'rebox-mode
    "gr" 'rebox-dwim)
  :config
  (add-to-list 'rebox-language-character-alist '(7 . "!"))
  (setq rebox-regexp-start (vconcat rebox-regexp-start '("^[ \t]*!+")))
  (rebox-register-all-templates))
#+END_SRC
** flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config
  (global-flycheck-mode)
  (general-def
    :states '(motion normal)
    "]a" 'flycheck-next-error
    "[a" 'flycheck-previous-error
    "]A" 'flycheck-first-error)
  (ans-leader-def
    :states '(motion normal)
    "!" 'flycheck-list-errors)
  (defun disable-flycheck-in-org-src-edit ()
    "Disable some Flycheck features when editing an org src block."
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
  (add-hook 'org-src-mode-hook 'disable-flycheck-in-org-src-edit))
#+END_SRC
** simpleclip

#+BEGIN_SRC emacs-lisp
(use-package simpleclip
  :ensure t
  :config
  (simpleclip-mode 1))
#+END_SRC
** smartparens

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config
  (require 'smartparens-config)
  (general-def
    :states 'insert
    "C-0" 'ans/sp-slurp-and-end
    "C-9" 'sp-forward-barf-sexp)
  (general-def
    :states '(motion normal visual insert)
    "M-]" 'sp-end-of-sexp
    "M-[" 'sp-beginning-of-sexp
    "M-." 'sp-next-sexp
    "M-," 'sp-backward-sexp))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun ans/sp-slurp-and-end ()
  "Slurp up sexp and move to its end."
  (interactive)
  (sp-forward-slurp-sexp)
  (sp-end-of-sexp))
#+END_SRC

Here's a hydra for navigating lisp code.

#+BEGIN_SRC emacs-lisp :tangle no
(setq sp-navigate-interactive-always-progress-point t)

(defhydra ans/smartparen-hydra (:foreign-keys run)
  "Smartparens"
  ("n" sp-next-sexp "Next")
  ("p" sp-previous-sexp "Prev")
  ("f" sp-forward-sexp "Forward")
  ("b" sp-backward-sexp "Backward")
  ("k" sp-up-sexp "Up")
  ("j" sp-down-sexp "Down")
  ("e" sp-end-of-sexp "End")
  ("b" sp-beginning-of-sexp "Beginning")
  ("-" sp-split-sexp "Split")
  ("J" sp-join-sexp "Join")
  ("q" nil "Quit"))
#+END_SRC
** lispyville

#+BEGIN_SRC emacs-lisp
(use-package lispyville
  :ensure t
  :hook ((lisp-mode emacs-lisp-mode lisp-interaction-mode) . lispyville-mode))
#+END_SRC

** edit-server

#+BEGIN_SRC emacs-lisp
;; For editing text fields in the browser
(use-package edit-server
  :ensure t
  :config
  (edit-server-start))
#+END_SRC
** adaptive-wrap

#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap
  :ensure t
  :hook (visual-line-mode . adaptive-wrap-prefix-mode))
#+END_SRC
** expand-region

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :init
  (setq expand-region-contract-fast-key ",")
  :general
  (general-def
    :states 'motion
    "z." 'er/expand-region))
#+END_SRC
** fill-function-arguments

#+BEGIN_SRC emacs-lisp
(use-package fill-function-arguments
  :quelpa (fill-function-arguments
           :fetcher github
           :repo "davidshepherd7/fill-function-arguments")
  :general
  (general-def
    :states 'normal
    "gs" 'ans/fill-function-arguements-and-indent))
#+END_SRC

Define a custom function that calls ~fill-function-arguments~ and then re-indents the expression.

#+BEGIN_SRC emacs-lisp
(defun ans/fill-function-arguements-and-indent ()
  "Fill function arguments and indent."
  (interactive)
  (fill-function-arguments-dwim)
  (let ((start (save-excursion (sp-beginning-of-sexp) (point)))
        (end (save-excursion (sp-end-of-sexp) (point))))
    (indent-region start end)))
#+END_SRC

** aggressive-indent

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :disabled
  ;; :ensure t
  :hook (prog-mode . aggressive-indent-mode)
  :config
  (add-to-list 'aggressive-indent-excluded-modes 'makefile-mode)
  (ans-leader-def
    :states 'normal
    "I" 'aggressive-indent-mode))
#+END_SRC
** undo-tree

NOTE: This is temporarily disabled.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :disabled
  :ensure t
  :init
  (setq undo-tree-history-directory-alist `(("." . "~/.emacs.d/undo"))
        undo-tree-auto-save-history t)
  :config
  (global-undo-tree-mode))
#+END_SRC
** hl-todo

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :ensure t
  :config
  (global-hl-todo-mode)
  (defhydra hl-todo-hydra ()
    "Browse todo tags."
    ("n" hl-todo-next "Next")
    ("p" hl-todo-previous "Previous"))
  (ans-leader-def
    :states 'normal
    "t" 'hl-todo-hydra/body))
#+END_SRC

Function to use ~org-ref~ for notes rather than bibtex defaults.

#+BEGIN_SRC emacs-lisp
(defun ans/org-ref-notes-function (candidates)
  "Helm bibtex completion function to insert notes for marked CANDIDATES."
  (let ((key (helm-marked-candidates)))
    (funcall org-ref-notes-function (car key))))
#+END_SRC
** dumb-jump

Quickly jump to definitions based on regular expression search (not tags or anything more robust).

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :init
  (setq dumb-jump-selector 'helm)
  (setq dumb-jump-force-searcher 'ag)
  :general
  (general-def
    :states 'normal
    "gd" 'dumb-jump-go
    "gD" 'ans/dumb-jump-hydra/body))

(defhydra ans/dumb-jump-hydra (:exit t)
  "Dumb jump."
  ("d" dumb-jump-go "Go")
  ("D" evil-goto-definition "Evil goto def")
  ("o" dumb-jump-go-other-window "Other window")
  ("b" dumb-jump-back "Back"))
#+END_SRC
** slime

Superior Lisp Interaction Mode for Emacs (SLIME)

#+BEGIN_SRC emacs-lisp
(use-package slime
  :ensure t
  :commands slime
  :init
  (setq inferior-lisp-program "/usr/bin/sbcl"))
#+END_SRC

** dtrt-indent

Automatically detect current file indent (similar to =vim-sleuth=).

#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t)
#+END_SRC

** ANSI colors in compilation buffer

So the output doesn't come out as jumbled.
Based on [[https://stackoverflow.com/questions/13397737/ansi-coloring-in-compilation-mode][this Stack Overflow question]].

#+BEGIN_SRC emacs-lisp
(require 'ansi-color)
(defun ans/colorize-compilation-buffer ()
  "Add ANSI colors to compilation buffer."
  (toggle-read-only)
  (ansi-color-apply-on-region compilation-filter-start (point))
  (toggle-read-only))
(add-hook 'compilation-filter-hook 'ans/colorize-compilation-buffer)
#+END_SRC

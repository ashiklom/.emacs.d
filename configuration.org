#+TITLE: My Emacs configuration
#+AUTHOR: Alexey Shiklomanov
#+PROPERTY: header-args :tangle yes :results silent :comments both

* Personal information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Alexey Shiklomanov"
      user-mail-address "alexey.shiklomanov@gmail.com")
#+END_SRC
* Package management
** Core emacs package manager

Load Emacs's internal package manager and tell it where to look for packages.

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'package)
  (setq package-enable-at-startup nil)
  (unless (assoc-default "org" package-archives)
    (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/")))
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/")))
  (unless (assoc-default "melpa-stable" package-archives)
    (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/")))
  (package-initialize))
#+END_SRC

** use-package

Bootstrap the ~use-package~ package manager.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile (require 'use-package))
#+END_SRC

** System packages

#+BEGIN_SRC emacs-lisp
(use-package use-package-ensure-system-package
  :ensure t
  :config
  (setq system-packages-package-manager 'brew))
#+END_SRC

Declare that system packages are required with code like the following:

#+BEGIN_SRC emacs-lisp :tangle no :eval no
(use-package rg
  :ensure-system-package rg)

(use-package tern
  :ensure-system-package (tern . "npm i -g tern"))

(use-package ruby-mode
  :ensure-system-package
  ((rubocop . "gem install rubocop")
   (ruby-lint . "gem install ruby-lint")))
#+END_SRC

** quelpa

For installing packages from source (e.g. GitHub).

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :ensure t
  :init
  (setq quelpa-update-melpa-p nil))
(use-package quelpa-use-package :ensure t)
#+END_SRC

** Restart Emacs in place

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :ensure t)
#+END_SRC

** Recursively unload package

Unload a feature and all of its dependencies.

#+BEGIN_SRC emacs-lisp :tangle no
(defun ans/unload-feature-recursive (feature)
  "Unload a feature and all of its dependents."
  (interactive
   (list (read-feature "Unload feature: " t)))
  (let* ((file (feature-file feature))
         (dependents (delete file (copy-sequence (file-dependents file))))) 
    (if dependents
        (mapc #'ans/unload-feature-recursive (mapcan #'file-provides dependents))
      (unload-feature feature))))
#+END_SRC
* Lisp libraries
** dash -- list manipulation

#+BEGIN_SRC emacs-lisp
(use-package dash :ensure t)
(use-package dash-functional :ensure t)
#+END_SRC
** f -- working with files

#+BEGIN_SRC emacs-lisp
(use-package f :ensure t)
#+END_SRC
** Custom libraries

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+END_SRC

* Native emacs settings
** custom.el file

Configure the ~custom.el~ file.
Mostly, I avoid this in favor of ~setq~ settings.
Note the use of ~f-touch~ to ensure that the file exists.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(f-touch custom-file)
(load custom-file)
#+END_SRC

** Backups and history

Create version-controlled backups of all files Emacs touches.
Save them in =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups"))
      delete-old-versions -1		; Don't delete old versions
      version-control t			; Version control backups
      make-backup-files t
      vc-make-backup-files t		; Backup files even if they are version controlled
      auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t))) ; Save file name changes
#+END_SRC

** Start emacs server

This allows me to open Emacs quickly from external programs, most importantly the command line.

#+BEGIN_SRC emacs-lisp
(if (not (server-running-p))
    (server-start))
#+END_SRC

Also, configure the server for remote editing, based on [[https://andy.wordpress.com/2013/01/03/automatic-emacsclient/][this guide.]]

#+BEGIN_SRC emacs-lisp :tangle no
(setq server-use-tcp t
      server-port 9999)
(defun ans/server-start-and-copy ()
  "Start emacs server and copy file to PIC."
  (interactive)
  (server-start)
  (copy-file "~/.emacs.d/server/server" "/ssh:pic:.emacs.d/server/server" t))
#+END_SRC

** Other settings

Sentences should end with a single space, not a double space.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Start with a blank scratch buffer.
No need for startup messages, splash screens, etc.

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC

Scroll conservatively, like vim does.
~scroll-margin~ is the guaranteed number of lines displayed above or below a cursor.
~scroll-conservatively~ determines how aggressively to auto-scroll.
Auto-scrolling in Emacs scrolls the buffer until the cursor is at the center of the screen, which is pretty distracting.
At a value >100, this means don't do any auto-scrolling (i.e. only ever scroll one line at a time).

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 2
      scroll-conservatively 101)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0
      abbrev-file-name (expand-file-name "abbrev_defs" user-emacs-directory)
      save-abbrevs 'silent
      auto-save-default nil
      column-number-mode t
      compilation-scroll-output t)

(setq-default indicate-empty-lines t)

(show-paren-mode 1)
(set-face-attribute 'show-paren-match nil :foreground nil :background "dim gray")

(tool-bar-mode -1)
(menu-bar-mode -1)
(blink-cursor-mode -1)
(global-hl-line-mode)
(winner-mode)				; Remember window configurations
(electric-pair-mode 1)
#+END_SRC

** PNNL mac settings

Note that BSD ~tar~ (the default for MacOS) gets tripped up by certain package names, so when running on MacOS, I use GNU tar (~gtar~) instead.

#+BEGIN_SRC emacs-lisp
(when (string-equal system-type "darwin")
  (setq exec-path (append exec-path '("/usr/local/bin")))
  (setq mac-option-modifier 'meta)
  (let* ((gtar (executable-find "gtar")))
    (if gtar
        (setq quelpa-build-tar-executable gtar)
      (warn (concat "Did not find gtar executable. "
                    "Some packages may not install properly. "
                    "Please install 'gnu-tar' with 'brew install gnu-tar'")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (string-equal system-type "darwin")
  :ensure t
  :init
  (setq exec-path-from-shell-check-startup-files nil)
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

* Global variables

Related to bibtex references.

#+BEGIN_SRC emacs-lisp
(defvar ans/reference-dir (file-name-as-directory "~/Dropbox/references")
  "Root directory for storing my bibliography.")
(defvar ans/reference-dir-pdfs (file-name-as-directory (concat ans/reference-dir "pdfs"))
  "Subdirectory containing PDF files of papers in my bibliography.")
(defvar ans/reference-bibfile (concat ans/reference-dir "library.bib")
  "Full path to my personal bibtex file.")
(defvar ans/reference-notes (concat ans/reference-dir "notes.org")
  "Full path to reference-related notes.")
#+END_SRC

Automatically don't save before compiling.

#+BEGIN_SRC emacs-lisp
(setq compilation-save-buffers-predicate 'ignore)
#+END_SRC

By default, use spaces instead of tabs.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

* Text and prog mode hooks

#+BEGIN_SRC emacs-lisp
(defun ans-prog-mode-setup ()
  "My custom setup for prog mode."
  (toggle-truncate-lines 1)
  (flyspell-prog-mode)
  (setq comment-auto-fill-only-comments t)
  (auto-fill-mode 1))
(defun ans-text-mode-setup ()
  "My custom configuration for text mode."
  (visual-line-mode)
  (flyspell-mode))
(add-hook 'prog-mode-hook #'ans-prog-mode-setup)
(add-hook 'text-mode-hook #'ans-text-mode-setup)
#+END_SRC

* Aesthetics
** Color scheme and font

#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-tomorrow
  :ensure t
  :config
  (color-theme-sanityinc-tomorrow-night))

(defvar target-font "Input Mono Narrow-12" "My preferred Emacs font.")

(if (and (display-graphic-p) (x-list-fonts target-font))
     (set-face-attribute 'default nil :font target-font))
#+END_SRC
** Cursor type

Don't show cursor in non-selected window.
This is mostly to avoid annoying visual artifacts of a hollow box cursor.

#+BEGIN_SRC emacs-lisp
(setq cursor-in-non-selected-windows nil)
#+END_SRC
** delight

Customize how major and minor modes appear in the modeline.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :ensure t
  :config
  (delight '((lispyville-mode nil lispyville)
             (yas-minor-mode nil yasnippet)
             (helm-mode nil helm)
             (company-mode nil company)
             (company-quickhelp-mode nil company-quickhelp)
             (evil-org-mode nil evil-org)
             (org-indent-mode nil org-indent)
             (flycheck-mode " ðŸ›" flycheck)
             (flyspell-mode " ð€ðð‚" flyspell)
             (visual-line-mode " â†©" simple)
             (adaptive-wrap-prefix-mode " â¥±" adaptive-wrap)
             (auto-revert-mode " â†»" autorevert)
             (undo-tree-mode nil undo-tree)
             (eldoc-mode nil eldoc)
             (winner-mode nil winner))))
#+END_SRC
** rainbow-delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook ((prog-mode) . rainbow-delimiters-mode))
#+END_SRC

** Mode line

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :config
  (sml/setup))
#+END_SRC
** Fill column indicator

Visual indicator at whatever the current fill column is (usually 80 characters).
My preferred solution uses only native Emacs's whitespace mode.
(Note that I currently don't actively use ~whitespace-mode~, so this is never enabled.)

#+BEGIN_SRC emacs-lisp
(setq-default whitespace-line-column 80
              whitespace-style '(face lines-tail))
#+END_SRC

This is another solution using a (no longer maintained, and arguably buggy) package.

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :disabled
  :ensure t
  :commands (fci-mode turn-off-fci-mode turn-on-fci-mode))
#+END_SRC

* Keybindings
** general

#+BEGIN_SRC emacs-lisp
(use-package general
  :ensure t)
#+END_SRC

Unbind keys that I'll need elsewhere.
~SPC~ is my leader key.
~C-u~ is useful for scrolling.
~\~ is my "local leader".

#+BEGIN_SRC emacs-lisp
(general-unbind
  :states '(motion normal visual)
  "SPC"
  "C-u"
  "\\"
  "K")
(general-unbind "M-SPC")
#+END_SRC

Create a custom definer to emulate Vim's leader key.
My leader key is SPACE.

#+BEGIN_SRC emacs-lisp
(general-create-definer ans-leader-def
  :prefix "SPC"
  :non-normal-prefix "M-SPC"
  :prefix-command 'ans-leader-command
  :prefix-map 'ans-leader-map)
#+END_SRC

** hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC
** evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil)
  :config
  (evil-mode)
  (defalias #'forward-evil-word #'forward-evil-symbol))
#+END_SRC

** Evil extensions
*** evil-collection
#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :ensure t
  :after evil
  :init
  (setq evil-collection-company-use-tng nil)
  :config
  (setq evil-collection-mode-list (remove '(company magit) evil-collection-mode-list))
  (evil-collection-init))
#+END_SRC
*** evil-surround

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :after evil
  :config
  (global-evil-surround-mode))
#+END_SRC
*** evil-embrace
#+BEGIN_SRC emacs-lisp
(use-package evil-embrace
  :ensure t
  :after evil
  :init
  (setq evil-embrace-show-help-p nil)
  :config
  (evil-embrace-enable-evil-surround-integration)
  (add-hook 'org-mode-hook 'embrace-org-mode-hook)
  (add-hook 'LaTeX-mode-hook 'embrace-LaTeX-mode-hook))
#+END_SRC

*** evil-indent-textobject

#+BEGIN_SRC emacs-lisp
(use-package evil-indent-textobject
  :ensure t
  :after evil)
#+END_SRC

*** evil-nerd-commenter

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :ensure t
  :general
  (ans-leader-def
    :states '(normal visual)
    ";" 'evilnc-comment-or-uncomment-lines))
#+END_SRC

*** evil-easymotion

#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion
  :ensure t
  :after evil
  :config
  (general-def
    :states '(normal motion visual)
    "SPC SPC" evilem-map))
#+END_SRC

*** evil-exchange

#+BEGIN_SRC emacs-lisp
(use-package evil-exchange
  :ensure t
  :after evil
  :config
  (evil-exchange-install))
#+END_SRC

*** evil-numbers

#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
  :ensure t
  :after evil
  :init
  (defhydra evil-numbers-hydra ()
    "Increment or decrement numbers."
    ("=" evil-numbers/inc-at-pt "Increment")
    ("-" evil-numbers/dec-at-pt "Decrement"))
  :general
  (general-def
    :states 'normal
    "C-a" 'evil-numbers-hydra/body))
#+END_SRC

*** evil-magit

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  :ensure t
  :after magit)
#+END_SRC

*** evil-latex-textobjects

#+BEGIN_SRC emacs-lisp
(use-package evil-latex-textobjects
  :quelpa (evil-latex-textobjects :fetcher github :repo "hpdeifel/evil-latex-textobjects")
  :config
  (add-hook 'LaTeX-mode-hook 'turn-on-evil-latex-textobjects-mode))
#+END_SRC

*** evil-matchit

Temporarily disable this.

Supercharges =%= to jump between other stuff as well (e.g. if-else statements).
I also tried to expand it to R, but it doesn't currently work.

#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :disabled
  :ensure t
  :after evil
  :config
  (global-evil-matchit-mode 1)
  (require 'evil-matchit-sdk)
  (defvar ans/evilmi-r-match-tags
    '(("if" "else if" "else")
      ("function" "return" ())
      (("for" "while") ("break") ())))
  (defun ans/evilmi-r-get-tag ()
    (evilmi-sdk-get-tag ans/evilmi-r-match-tags
                        evilmi-sdk-extract-keyword-howtos))
  (defun ans/evilmi-r-jump (rlt num)
    (evilmi-sdk-jump rlt
                     num
                     ans/evilmi-r-match-tags
                     evilmi-sdk-extract-keyword-howtos))
  (plist-put evilmi-plugins 'r-mode '((ans/evilmi-r-get-tag ans/evilmi-r-jump))))
#+END_SRC
*** evil-mc (multiple cursors)

#+BEGIN_SRC emacs-lisp
(use-package evil-mc
  :ensure t
  :config
  (global-evil-mc-mode 1)
  (general-def
    :states 'visual
    "grn" 'evil-mc-make-and-goto-next-match
    "grp" 'evil-mc-make-and-goto-prev-match
    "grN" 'evil-mc-skip-and-goto-next-match
    "grP" 'evil-mc-skip-and-goto-next-match)
  (general-def
    :states 'normal
    "grg" 'evil-mc-mode
    "gru" 'evil-mc-undo-all-cursors
    "grh" (lambda() (interactive) (evil-mc-make-cursor-here) (evil-mc-pause-cursors))
    "grp" 'evil-mc-pause-cursors
    "grr" 'evil-mc-resume-cursors
    "grn" 'evil-mc-make-and-goto-next-match
    "grp" 'evil-mc-make-and-goto-prev-match
    "grN" 'evil-mc-skip-and-goto-next-match
    "grP" 'evil-mc-skip-and-goto-next-match))
#+END_SRC

** Universal argument

Change universal argument from ~C-u~ (which I use for scrolling) to ~M-u~.

#+BEGIN_SRC emacs-lisp
(general-def "M-u" 'universal-argument)
#+END_SRC
** Insert state
#+BEGIN_SRC emacs-lisp
(general-def
  :states 'insert
  "j" (general-key-dispatch 'self-insert-command
        :timeout 0.25
        "k" 'evil-normal-state)
  "C-s" '(lambda ()(interactive)(upcase-word -1))
  "C-S-s" '(lambda ()(interactive)(capitalize-word -1)))
#+END_SRC

** Normal, visual, and motion states

#+BEGIN_SRC emacs-lisp
(general-def
  :states '(motion normal visual)
  ;; Move by visual lines
  "j" 'evil-next-visual-line
  "k" 'evil-previous-visual-line
  "gj" 'evilem-motion-next-line
  "gk" 'evilem-motion-previous-line
  "C-=" 'evil-window-increase-height
  "C--" 'evil-window-decrease-height
  "C-+" 'evil-window-increase-width
  "C-_" 'evil-window-decrease-width
  "C-0" 'balance-windows
  "C-)" 'shrink-window-if-larger-than-buffer
  "C-d" 'evil-scroll-down
  "C-u" 'evil-scroll-up)
#+END_SRC

** Leader mappings

#+BEGIN_SRC emacs-lisp
(ans-leader-def
  :states '(motion normal visual emacs)
  :keymaps 'override
  "b" 'helm-mini
  "B" 'helm-bookmarks
  "f" 'helm-find-files
  "F" #'find-file
  ":" 'eval-expression
  "x" 'helm-M-x
  "X" 'shell-command
  "sv" 'ans--reload-initfile
  "sx" (lambda() (interactive) (switch-to-buffer "*scratch*"))
  "ss" 'delete-trailing-whitespace
  "'" 'comment-dwim			; Insert right comment
  "vl" 'visual-line-mode
  "/" 'helm-occur
  "\"" 'helm-show-kill-ring
  "mm" 'compile
  "w"  'ans/buffer-window-hydra/body
  "p" 'ans/projectile-hydra/body
  "h" 'ans/help-hydra/body
  "o" 'ans/org-mode-hydra/body
  "*" 'ans/replace-symbol-at-point
  ">" #'ans/kill-ring-to-clipboard
  "_" #'universal-argument)
#+END_SRC

Add ~-~ to ~universal-argument~ map.

#+BEGIN_SRC emacs-lisp
(general-def
  :keymaps 'universal-argument-map
  "_" #'universal-argument-more)
#+END_SRC

** Quick save with "S"

#+BEGIN_SRC emacs-lisp
(general-def
  :states 'normal
  "S" (general-predicate-dispatch nil
	(buffer-file-name) 'save-buffer))
#+END_SRC

** Hydra for emacs help

#+BEGIN_SRC emacs-lisp
(defhydra ans/help-hydra (:exit t)
  "Emacs help."
  ("v" describe-variable "Variable")
  ("V" (describe-variable (variable-at-point)))
  ("f" describe-function "Function")
  ("F" (describe-function (function-called-at-point)))
  ("k" describe-key "Key")
  ("b" describe-bindings "Bindings")
  ("P" describe-package "Package")
  ("a" apropos-command "Apropos command")
  ("A" (let ((current-pre	fix-arg '(4))) (call-interactively 'apropos-command)) "Apropos all")
  ("m" describe-mode "Mode")
  ("M" (describe-variable current-major-mode) "Major mode")
  ("i" helm-info "Helm info"))
#+END_SRC
** Hydra for projectile

#+BEGIN_SRC emacs-lisp
(defhydra ans/projectile-hydra (:exit t)
  "Projectile"
  ("p" helm-projectile "Helm projectile")
  ("o" helm-projectile-switch-project "Switch project")
  ("b" helm-projectile-switch-to-buffer "Switch buffer")
  ("f" helm-projectile-find-file "Find file")
  ("F" helm-projectile-find-file-in-known-projects "Find file in known projects")
  ("d" projectile-dired "Dired")
  ("D" projectile-dired-other-window "Dired other window")
  ("r" helm-projectile-recentf "Recent file")
  ("c" projectile-compile-project "Compile")
  ("e" projectile-run-eshell "Eshell")
  ("g" helm-projectile-ag "Ag search")
  ("E" projectile-edit-dir-locals "Edit dir-locals")
  ("Q" projectile-kill-buffers "Kill buffers")
  ("!" projectile-commander))
#+END_SRC
** Hydra for buffer and window operations

#+BEGIN_SRC emacs-lisp
(defhydra ans/buffer-window-hydra (:exit t :hint nil)
  "
  Buffers: _w_:quit _W_:kill    Windows: _d_elete  _D_elete and kill    Frames: _f_:pop _F_:new     Split: _\\_:vert  _-_:horiz
  Switch:  _h__j__k__l_  Move (far = g): _H__J__K__L_    Misc: _u_ revert   _s_ave as   _z_:undo   _Z_:redo   _SPC_: Last  _r_:Rotate"
  ("w" quit-window)
  ("W" (kill-buffer (current-buffer)))
  ("d" evil-window-delete)
  ("D" kill-buffer-and-window)
  ("f" ans/pop-window-into-frame)
  ("F" make-frame-command)
  ("u" revert-buffer)
  ("s" write-file)
  ("\\" evil-window-vsplit)
  ("-" evil-window-split)
  ("j" windmove-down)
  ("h" windmove-left)
  ("k" windmove-up)
  ("l" windmove-right)
  ("J" buf-move-down)
  ("H" buf-move-left)
  ("K" buf-move-up)
  ("L" buf-move-right)
  ("gj" evil-window-move-very-bottom)
  ("gk" evil-window-move-very-top)
  ("gl" evil-window-move-far-right)
  ("gh" evil-window-move-far-left)
  ("z" winner-undo)
  ("Z" winner-redo)
  ("+" zoom-window-zoom)
  ("r" ans/rotate-window-hydra/body)
  ("SPC" ans/mru-window)
  ("0" (balance-windows (window-parent)))
  ("=" balance-windows))

(defhydra ans/rotate-window-hydra (:color 'pink)
  "Rotate window or layout"
  ("l" rotate-layout "Layout")
  ("w" rotate-window "Window"))
#+END_SRC

** Evaluate lisp at point

Evaluate lisp at point.

#+BEGIN_SRC emacs-lisp
(general-def
  :keymaps 'lisp-mode-shared-map
  :states '(motion insert)
  "<C-return>" 'eval-defun)
#+END_SRC
** Evil-like movement in other modes

#+BEGIN_SRC emacs-lisp
(defun ans/add-evil-maps (keymap)
  "Add some basic navigation mappings (including hjkl) to KEYMAP."
  (general-def
    :keymaps keymap
    "h" 'evil-backward-char
    "l" 'evil-forward-char
    "k" 'evil-previous-visual-line
    "j" 'evil-next-visual-line
    "C-u" 'evil-scroll-up
    "C-d" 'evil-scroll-down
    "/" 'evil-search-forward
    "n" 'evil-search-next
    "N" 'evil-search-previous))

(ans/add-evil-maps 'occur-mode-map)
#+END_SRC
** avy

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :general
  (general-def
    :states 'motion
    :prefix "SPC SPC"
    "c" #'avy-goto-word-or-subword-1
    "SPC" #'avy-goto-char-timer
    "l" #'avy-goto-line))
#+END_SRC
* Buffer and window management

** dired

#+BEGIN_SRC emacs-lisp
(use-package dired
  :general
  (ans-leader-def
    :states 'normal
    "dd" 'dired
    "dw" 'dired-other-window)
  :config
  (setq dired-listing-switches "-alh")
  (general-def
    :keymaps 'dired-mode-map
    "SPC" 'ans-leader-command))
#+END_SRC

** ace-window

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :commands ace-window
  :general
  (general-def
    :keymaps 'override
    "M-o" 'ace-window)
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (add-hook 'ace-window-mode (lambda () (toggle-truncate-lines 1))))
#+END_SRC
** buffer-move

Swap buffer positions.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move :ensure t)
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :init
  (setq projectile-mode-line '(:eval (format " ðŸ•®%sðŸ•®" (projectile-project-name))))
  :config
  (projectile-mode))
#+END_SRC

Function to check if I'm inside of a projectile project.

#+BEGIN_SRC emacs-lisp
(defun ans/in-project-p ()
  "Check if current buffer is in a projectile project."
  (ignore-errors (projectile-project-root)))
#+END_SRC
** perspective

Like "tabs" in Emacs.
Note that this is lazy-loaded on =persp-switch= thanks to the =:commands= keyword.

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :init
  (setq persp-mode-prefix-key (kbd "<C-SPC>"))
  :config
  (persp-mode)
  :general
  (general-def
    :states 'normal
    "C-SPC s" 'persp-switch))
#+END_SRC
** treemacs

Better file and project manager.
Note that all of these are lazy-loaded thanks to the =:general= keyword.

#+BEGIN_SRC emacs-lisp
(use-package treemacs
  :disabled
  :ensure t
  :general
  (ans-leader-def
    :states 'normal
    "dd" 'treemacs
    "df" 'treemacs-find-file
    "dw" 'treemacs-select-window
    "dp" 'treemacs-projectile
    "db" 'treemacs-bookmark))

(use-package treemacs-evil
  :disabled
  :after treemacs evil
  :ensure t)

(use-package treemacs-projectile
  :disabled
  :after treemacs projectile
  :ensure t)
#+END_SRC
** zoom-window

Temporarily "zoom" windows into full screen, like in ~tmux~.

#+BEGIN_SRC emacs-lisp
(use-package zoom-window
  :ensure t
  :config
  (ans-leader-def
    :states '(normal motion)
    "z" 'zoom-window-zoom))
#+END_SRC
** Shackle

Special window rules.

#+BEGIN_SRC emacs-lisp
(use-package shackle
  :ensure t
  :config
  (setq shackle-rules '((compilation-mode :noselect t)))
  (shackle-mode))

(defun ans/align-if-wide-enough ()
  "Split the window to the right if there is sufficient space; otherwise, split vertically."
  (if (< (window-total-width) 140) 'below 'right))
#+END_SRC
** Rotate window layout (`rotate.el`)

#+BEGIN_SRC emacs-lisp
(use-package rotate
  :ensure t
  :commands (rotate-layout rotate-window))
#+END_SRC
** Custom functions
*** Most recently used window

#+BEGIN_SRC emacs-lisp
(defun ans/mru-window ()
  "Switch to most recently used window."
  (interactive)
  (let ((win (get-mru-window t t t)))
    (unless win (error "Last window not found"))
    (let ((frame (window-frame win)))
      (raise-frame frame)
      (select-frame frame)
      (select-window win))))
#+END_SRC
* Version control
** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :general
  (ans-leader-def
    :states 'normal
    "g s" 'magit-status
    "g b" 'magit-blame)
  :config
  (general-def
    :states 'normal
    :keymaps 'magit-status-mode-map
    "gd" 'magit-diff-toggle-refine-hunk))
#+END_SRC
** magithub

#+BEGIN_SRC emacs-lisp
(use-package magithub
  :disabled
  :ensure t
  :commands (magithub-clone)
  :general
  (ans-leader-def
    :states '(normal motion emacs)
    "gd" 'magithub-dashboard)
  :config
  (magithub-feature-autoinject t)
  (general-def
    :keymaps 'magithub-dash-map
    :states 'normal
    "gu" 'magithub-dashboard-show-read-notifications-toggle))
#+END_SRC
** forge

Currently disabled while functionality is evolving, but may revisit at a later point.

#+BEGIN_SRC emacs-lisp
(use-package forge
  :ensure t
  :after magit
  :config
  (general-def
    :states 'normal
    :keymaps 'magit-status-mode-map
    "h" #'forge-dispatch))
#+END_SRC
** gists

Quickly create and manipulate GitHub gists.

#+BEGIN_SRC emacs-lisp
(use-package gist
  :ensure t
  :general
  (ans-leader-def
    :states 'normal
    "gg" #'gist-list)
  (ans-leader-def
    :states '(normal visual)
    "gG" #'gist-region-or-buffer)
  :config
  (general-def
    :states 'emacs
    :keymaps 'gist-list-menu-mode-map
    "SPC" #'ans-leader-command
    "j" #'next-line
    "k" #'previous-line
    "d" #'gist-kill-current
    "w" #'gist-browse-current-url)
  (general-def
    :states 'normal
    :keymaps 'gist-mode-map
    "C-c C-c" #'gist-mode-save-buffer))
#+END_SRC
* Filetype modes
** markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode ("\\.Rmd$" "\\.md$" "\\.markdown$")
  :init
  (setq markdown-command "pandoc")
  :config
  (general-def
    :states 'normal
    :keymaps 'markdown-mode-map
    :prefix "\\"
    "p" #'ans/toggle-poly-markdown-mode))
#+END_SRC

Also, add Pandoc support.

#+BEGIN_SRC emacs-lisp
(use-package pandoc-mode
  :ensure t
  :config
  (add-hook 'markdown-mode-hook 'pandoc-mode))
#+END_SRC
** fence-edit

Edit code blocks in a separate window.

#+BEGIN_SRC emacs-lisp
(use-package fence-edit
  :quelpa (fence-edit :fetcher github :repo "aaronbieber/fence-edit.el")
  :config
  (add-to-list 'fence-edit-blocks '("^```{r.*}" "^```$" R))
  (add-to-list 'fence-edit-blocks '("^```{tikz.*}" "^```$" latex))
  (general-def
    :keymaps 'markdown-mode-map
    :states '(motion normal visual)
    "\\e" 'fence-edit-code-at-point)
  (general-def
    :keymaps 'fence-edit-mode-map
    "C-c C-c" 'fence-edit-exit
    "C-c C-k" 'fence-edit-abort))
#+END_SRC
** pdf-tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :disabled
  ;; :mode (("\\.pdf\\'" . pdf-view-mode))
  :config
  (pdf-tools-install)
  (general-def
    :states 'normal
    :keymaps 'pdf-view-mode-map
    "<" 'pdf-history-backward
    ">" 'pdf-history-forward))
#+END_SRC
** mmm-mode

Currently disabled.

#+BEGIN_SRC emacs-lisp
(use-package mmm-mode
  :disabled
  :ensure t
  :init
  (setq mmm-global-mode 'maybe
	mmm-submode-decoration-level 1
	mmm-parse-when-idle t
	mmm-idle-timer-delay 1)
  :config
  (mmm-add-classes
   '((ans-mmm-org-elisp
      :submode emacs-lisp-mode
      :face org-block
      :front "#\+BEGIN_SRC emacs-lisp"
      :front-offset -1
      :back "#\+END_SRC")
     (ans-mmm-org-r
      :submode R-mode
      :face org-block
      :front "#\+BEGIN_SRC R"
      :front-offset -1
      :back "\n#\+END_SRC")
     (ans-rmarkdown
      :submode r-mode
      :front "^```{r.*}"
      :front-offset -1
      :back "^```$")
     (ans-latex
      :submode latex-mode
      :front "^```{tikz.*}"
      :front-offset -1
      :back "^```$")))
  (mmm-add-mode-ext-class 'org-mode nil 'ans-mmm-org-elisp)
  (mmm-add-mode-ext-class 'org-mode nil 'ans-mmm-org-r))

;; (mmm-add-mode-ext-class 'markdown-mode "\\.Rmd\\'" 'ans-rmarkdown)
;; (mmm-add-mode-ext-class 'markdown-mode "\\.Rmd\\'" 'ans-latex))

#+END_SRC
** yaml

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :mode "\\.yml\\'")
#+END_SRC
** csv-mode

Currently disabled.

#+BEGIN_SRC emacs-lisp
(defun ans/csv-mode-settings ()
  "Custom settings for CSV mode."
  (toggle-truncate-lines -1))

(use-package csv-mode
  :disabled
  :ensure t
  :mode "\\.csv\\'"
  :hook (csv-mode . ans/csv-mode-settings))
#+END_SRC
** open with

Set default external programs for certain filetypes.

#+BEGIN_SRC emacs-lisp
(use-package openwith
  :if (string-equal system-type "darwin")
  :ensure t
  :config
  (setq openwith-associations
        (list
         (list (openwith-make-extension-regexp
                '("pdf" "png" "jpg" "tiff" "svg"
                  "doc" "xls" "ppt"
                  "odt" "ods" "odp"
                  "mpg" "mpeg" "mp3" "mp4" "avi"))
               "open" '(file))))
  (openwith-mode t))
#+END_SRC
** Docker

Major modes for editing ~docker~ and ~docker-compose~ files.

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :quelpa (dockerfile-mode :fetcher github :repo "ashiklom/dockerfile-mode")
  :mode "\\`Dockerfile")

(defun ans/dockerfile-settings ()
  "Settings for dockerfile-mode"
  (setq indent-tabs-mode nil))

(add-hook 'dockerfile-mode-hook 'ans/dockerfile-settings)

(use-package docker-compose-mode
  :ensure t)
#+END_SRC

The [[https://github.com/Silex/docker.el][docker]] package for performing docker commands directly from within Emacs.

#+BEGIN_SRC emacs-lisp
(use-package docker
  :disabled
  :ensure t
  :general
  (ans-leader-def
    :states 'normal
    "D" 'docker))
#+END_SRC
** Polymode

Multiple major modes in a single file.
Mostly useful for R markdown files (R + markdown).

#+BEGIN_SRC emacs-lisp
(use-package polymode
  :ensure t
  :general
  (general-def
    :states '(normal motion)
    :keymaps 'polymode-mode-map
    "g]" 'polymode-next-chunk
    "g[" 'polymode-previous-chunk
    "g-" 'polymode-kill-chunk))

(use-package poly-markdown
  :ensure t
  :after polymode
  :commands (poly-markdown-mode)
  :config
  (general-def
    :states 'normal
    :keymaps '(poly-markdown-mode-map)
    :prefix "\\"
    "p" #'ans/toggle-poly-markdown-mode
    "r" #'ans/reload-polymode
    "`" #'ans/chunk-hydra/body)
  (general-def
    :states 'insert
    :keymaps 'poly-markdown-mode-map
    "C-'" 'ans/chunk-hydra/body))

(defun ans/insert-chunk-and-enter (chunktype)
  "Insert chunk of type CHUNKTYPE and enter it."
  (insert "```" chunktype "\n\n```")
  (previous-line)
  (beginning-of-line))

(defhydra ans/chunk-hydra (:exit t)
  "Insert chunks."
  ("`" (ans/insert-chunk-and-enter "") "Plain")
  ("r" (ans/insert-chunk-and-enter "{r}") "R (knitr)")
  ("R" (ans/insert-chunk-and-enter "r") "R (plain)")
  ("-" ans/poly-split-chunk-here "Split")
  ("SPC" polymode-toggle-chunk-narrowing))

(defun ans/poly-to-markdown-mode ()
  "Switch from polymode to markdown mode and kill polymode buffers."
  (interactive)
  (markdown-mode)
  (ans/kill-polymode-buffers))

(defun ans/toggle-poly-markdown-mode ()
  "Toggle poly-markdown mode."
  (interactive)
  (if (and (boundp 'poly-markdown-mode) poly-markdown-mode)
      (ans/poly-to-markdown-mode)
    (poly-markdown-mode)))

(defun ans/reload-polymode ()
  "Revert buffer and load poly-markdown-mode."
  (interactive)
  (save-buffer)
  (revert-buffer nil t)
  (poly-markdown-mode 1))

(defun ans/kill-polymode-buffers ()
  "List all polymode implementation buffers."
  (interactive)
  (let* ((b (buffer-name))
         (pattern (concat b "\\[.+\\]"))
         (matched-buffers (-filter (lambda (buf) (s-matches? pattern (buffer-name buf))) (buffer-list)))
         (n-matched (length matched-buffers)))
    (-map #'kill-buffer matched-buffers)
    (message "Killed %d polymode buffers." n-matched)))

(defun ans/poly-split-chunk-here ()
  "Split chunk into two chunks at point."
  (interactive)
  (beginning-of-line)
  (insert "```\n\n```")
  (previous-line)
  (beginning-of-line))

;; Other modes that could be useful
;; (use-package poly-R
;;   :ensure t)

;; (use-package poly-org
;;   :ensure t)
#+END_SRC
** web-mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode (("\\.php\\'" . web-mode)
	 ("\\.html\\'" . web-mode)))
#+END_SRC
** Python
Configure Elpy -- interactive Python development environment.

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :hook python-mode
  :init
  (setq python-shell-interpreter "jupyter"
        python-shell-interpreter-args "console --simple-prompt"
        python-shell-prompt-detect-failure-warning nil)
  :config
  (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
  (elpy-enable)
  (general-def
    :states 'normal
    :keymaps 'elpy-mode-map
    :prefix "\\"
    "rf" 'run-python
    "l" 'elpy-shell-send-statement
    "d" 'elpy-shell-send-statement-and-step
    "aa" 'elpy-shell-send-buffer))
#+END_SRC
** Graphviz

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :ensure t
  :mode "\\.gv\\'")
#+END_SRC
** Stan

#+BEGIN_SRC emacs-lisp
(use-package stan-mode
  :ensure t
  :mode "\\.stan\\'")
#+END_SRC
* Utility functions
** Rename buffer and file

#+BEGIN_SRC emacs-lisp
(defun rename-this-buffer-and-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

(evil-ex-define-cmd "rename" 'rename-this-buffer-and-file)
#+END_SRC
** Delete buffer and file

#+BEGIN_SRC emacs-lisp
(defun ans/delete-file-and-buffer ()
  "Kill the current buffer and delete the associated file."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (progn
        (delete-file filename)
        (message "Deleted file %s" filename)
        (kill-buffer)))))

(evil-ex-define-cmd "dkill" 'ans/delete-file-and-buffer)
#+END_SRC
** Switch to most recently used buffer

#+BEGIN_SRC emacs-lisp
(defun ans-switch-to-mru-buffer ()
  "Switch to most-recently-used (MRU) buffer."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))
#+END_SRC
** Reload init file

#+BEGIN_SRC emacs-lisp
(defun ans--reload-initfile ()
  "Reload the Emacs init file."
  (interactive)
  (load-file (expand-file-name "init.el" user-emacs-directory)))
#+END_SRC
** Pop window into own frame

#+BEGIN_SRC emacs-lisp
(defun ans/pop-window-into-frame ()
  "Pop current window into its own frame."
  (interactive)
  (let ((buffer (current-buffer)))
    (unless (one-window-p)
      (delete-window))
    (display-buffer-pop-up-frame buffer nil)))
#+END_SRC
** Align commas

Align a comma-separated table inside the current selection.
This is useful for complex R ~tribbles~.

#+BEGIN_SRC emacs-lisp
(defun ans/align-comma (start end)
  "Align comma-separated table."
  (interactive "r")
  (align-regexp start end
		"\\(\\s-*\\)," 1 1 t))

#+END_SRC
** Run shell commands

#+BEGIN_SRC emacs-lisp
(defun ans/shell-send-line ()
  "Run line at point as shell command."
  (interactive)
  (shell-command (buffer-substring-no-properties (line-beginning-position) (line-end-position))))

(defun ans/shell-send-region (start end)
  "Run selection as shell command."
  (interactive "r")
  (shell-command (buffer-substring-no-properties start end)))

(ans-leader-def
  :states 'normal
  "@" 'ans/shell-send-line)

(ans-leader-def
  :states 'visual
  "@" 'ans/shell-send-region)
#+END_SRC
** Find-replace symbol at point

#+BEGIN_SRC emacs-lisp
(defun ans/replace-symbol-at-point (replacement)
  "Replace symbol at point with value."
  (interactive "sReplacement: ")
  (save-excursion
    (query-replace (symbol-name (symbol-at-point)) replacement t)))
#+END_SRC
** Copy register to system clipboard

#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard t
      x-select-enable-clipboard t)

(defun ans/kill-ring-to-clipboard ()
  "Copy current kill ring to system clipboard"
  (interactive)
  (gui-select-text (current-kill 0)))
#+END_SRC
* Helm

Core helm configuration.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :demand
  :init
  (require 'helm-config)
  (setq helm-buffers-fuzzy-matching t)
  (setq helm-autoresize-mode t)
  (setq helm-buffer-max-length 20)
  (setq helm-mode-fuzzy-match t)
  ;; (setq helm-grep-ag-command
  ;; 	"rg --color=always --smart-case --no-heading --line-number %s %s %s")
  (setq helm-autoresize-max-height 40)
  (setq helm-display-function 'ans/helm-hsplit-frame)
  (setq helm-findutils-search-full-path t)
  ;; (setq find-program "fd")
  :config
  (helm-mode 1)
  (helm-autoresize-mode 1)
  ;; (use-package helm-rg :ensure t)
  (ans-leader-def
    :states 'normal
    "f" 'helm-find-files)
  (general-def
    :keymaps 'helm-map
    "TAB" 'helm-execute-persistent-action
    "C-z" 'helm-select-action
    "C-n" 'helm-next-line
    "C-p" 'helm-previous-line
    "C-d" 'helm-next-page
    "C-u" 'helm-previous-page
    "C-S-n" 'helm-next-source
    "C-S-p" 'helm-previous-source
    "C-l" 'helm-yank-selection)
  (general-def
    :keymaps '(helm-map
               helm-major-mode-map
               helm--minor-mode-map
               helm-find-files-map
               helm-projectile-find-file-map
               helm-read-file-map)
    "<right>" 'right-char
    "<left>" 'left-char
    "<C-backspace>" 'backward-kill-word)
  (general-def
    :keymaps '(helm-buffer-map)
    "C-;" 'ans/helm-buffer-hydra/body))
#+END_SRC

Buffer mode hydra.
See [[https://github.com/abo-abo/hydra/wiki/Helm-2][here]] and [[https://github.com/abo-abo/hydra/wiki/Helm-2][here]] for inspiration.

#+BEGIN_SRC emacs-lisp
(defhydra ans/helm-buffer-hydra (:color pink)
  "Helm buffer"
  ("k" helm-previous-line "Previous")
  ("j" helm-next-line "Next")
  ("{" helm-previous-source "Previous source")
  ("}" helm-next-source "Next source")
  ("C-d" helm-next-page "Pg Down")
  ("C-u" helm-previous-page "Pg Up")
  ("gg" helm-beginning-of-buffer "Top")
  ("G" helm-end-of-buffer "Bottom")
  ("m" helm-toggle-visible-mark "Mark")
  ("M" helm-toggle-all-marks "Mark all")
  ("A" helm-mark-all "Mark all")
  ("U" helm-unmark-all "Unmark all")
  ("x" helm-buffer-run-kill-persistent "Kill")
  ("gr" helm-buffer-run-grep "Grep")
  ("r" helm-buffer-run-rename-buffer "Rename")
  ("y" helm-yank-selection "Yank")
  ("v" helm-execute-persistent-action "View")
  ("f" helm-follow-mode "Follow")
  ("K" helm-scroll-other-window-down "Scroll down")
  ("J" helm-scroll-other-window "Scroll up")
  ("C-z" helm-select-action "Select action")
  ("i" nil "Insert")
  ("<escape>" 'helm-keyboard-quit "Back"))
#+END_SRC

** Split windows for helm

#+BEGIN_SRC emacs-lisp
(defun ans/hsplit-frame ()
  "Split window entirely below the current frame."
  (split-window (frame-root-window) nil 'below))

(defun ans/helm-hsplit-frame (buffer &optional _resume)
  "Open new window below frame, switch to it, and open BUFFER."
  (ans/hsplit-frame)
  (evil-window-bottom-right)
  (switch-to-buffer buffer))
#+END_SRC
** helm-ag

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :ensure t
  :after helm)
#+END_SRC
** helm-projectile

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t
  :init
  (setq helm-projectile-fuzzy-match t
        helm-projectile-truncate-lines t
        projectile-completion-system 'helm
        projectile-switch-project-action 'helm-projectile)
  :config
  (helm-projectile-on))
#+END_SRC
** helm-org-rifle

#+BEGIN_SRC emacs-lisp
(use-package helm-org-rifle
  :ensure t
  :init
  (setq helm-org-rifle-test-against-path t)
  :commands (helm-org-rifle-agenda-files helm-org-rifle-current-buffer))
#+END_SRC
** helm-swoop

#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :quelpa (helm-swoop :fetcher github :repo "ashiklom/helm-swoop")
  :init
  (setq helm-swoop-split-direction 'split-window-horizontally)
  :general
  (ans-leader-def
    :states '(motion normal)
    "ii" 'helm-swoop
    "ib" 'helm-multi-swoop-all
    "ip" 'helm-multi-swoop-projectile
    "i0" 'helm-swoop-back-to-last-point))
#+END_SRC
** helm-descbinds

#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :after helm
  :config
  (helm-descbinds-mode))
#+END_SRC
** helm-unicode

For easier unicode entry.

#+BEGIN_SRC emacs-lisp
(use-package helm-unicode
  :ensure t
  :commands (helm-unicode))
#+END_SRC
* Company

** Company core configuration

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (setq company-selection-wrap-around t
        company-idle-delay nil
        company-dabbrev-code-everywhere t
        company-dabbrev-code-modes t)
  (global-company-mode)
  ;; Thanks to this:
  ;; https://github.com/otijhuis/evil-emacs.d/blob/7c122b0e05c367192444a85d12323487422b793b/config/evil-settings.el#L38-L39
  (add-hook 'evil-insert-state-exit-hook (lambda ()(company-abort)))
  ;; See discussion in: https://github.com/expez/company-quickhelp/issues/17
  (add-hook 'company-completion-started-hook 'ans/set-company-maps)
  (add-hook 'company-completion-finished-hook 'ans/unset-company-maps)
  (add-hook 'company-completion-cancelled-hook 'ans/unset-company-maps)
  (add-to-list 'company-backends 'ans/org-keyword-backend)
  (general-def
    :states 'insert
    ;; See below for discussion of company-dabbrev-code
    ;; https://github.com/company-mode/company-mode/issues/360
    "C-f" 'ans/directory-file-backend
    "C-l" 'company-complete		; Note that this includes company-files
    )
  (general-def
    :states 'insert
    :keymaps 'prog-mode-map
    "C-n" 'company-dabbrev-code
    "C-p" 'company-dabbrev-code
    "C-S-n" 'company-dabbrev
    "C-S-p" 'company-dabbrev)
  (general-def
    :states 'insert
    :keymaps 'text-mode-map
    "C-n" 'company-dabbrev
    "C-p" 'company-dabbrev
    "C-S-n" 'company-dabbrev-code
    "C-S-p" 'company-dabbrev-code))
#+END_SRC

Additional functions needed to make ~company-quickhelp~ respect my keybindings.

#+BEGIN_SRC emacs-lisp
(defun ans/unset-company-maps (&rest unused)
  "Set default mappings (outside of company).
  Arguments (UNUSED) are ignored."
  (general-def
    :states 'insert
    :keymaps 'override
    "C-n" nil
    "C-p" nil
    "C-l" nil))

(defun ans/set-company-maps (&rest unused)
  "Set maps for when you're inside company completion.
  Arguments (UNUSED) are ignored."
  (general-def
    :states 'insert
    :keymaps 'override
    "C-n" 'company-select-next
    "C-p" 'company-select-previous
    "C-l" 'ans-company-complete-continue))

(defun ans-company-complete-continue ()
  "Insert the result of a completion, then re-start completion.
This makes repeat completions easier (e.g. when completing long file paths)."
  (interactive)
  (company-complete-selection)
  (company-complete))
#+END_SRC

** company-quickhelp

#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :ensure t
  :after company
  :config
  (setq company-quickhelp-delay nil)
  (company-quickhelp-mode)
  (general-def
    :keymaps 'company-active-map
    "?" 'company-quickhelp-manual-begin))
#+END_SRC

** Custom backends

*** Complete inside directory or projectile project

#+BEGIN_SRC emacs-lisp
(defun ans/directory-completion-candidates (prefix)
  "List files in projectile or current buffer directory that match PREFIX."
  (let* ((starting-directory
          (condition-case nil
              (projectile-project-root)
            (error "./")))
         (my-prefix-base (file-name-nondirectory prefix))
         (my-prefix-dir (file-name-directory prefix))
         (my-complete-dir (concat starting-directory my-prefix-dir))
         (my-completions-all
          (file-name-all-completions my-prefix-base my-complete-dir))
         (my-completions (-difference my-completions-all '("./" "../"))))
    (mapcar (lambda (file) (concat my-prefix-dir file)) my-completions)))

(defun ans/directory-file-backend (command &optional arg &rest ignored)
  "Complete files in current or projectile project directory.

COMMAND is command called by company.
ARG is the set of company completion arguments.
IGNORED are arguments ignored by company."
  (interactive (list 'interactive))
  (case command
    (interactive (company-begin-backend 'ans/directory-file-backend))
    (prefix (company-grab-line "\\(?:[\"\']\\|\\s-\\|^\\)\\(.*?\\)" 1))
    (candidates
     (remove-if-not
      (lambda (c) (string-prefix-p arg c))
      (ans/directory-completion-candidates arg)))))
#+END_SRC

*** Org keywords

#+BEGIN_SRC emacs-lisp
(defun ans/org-keyword-backend (command &optional arg &rest ignored)
  "Completion backend for org keywords (COMMAND, ARG, IGNORED)."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'org-keyword-backend))
    (prefix (and (eq major-mode 'org-mode)
                 (cons (company-grab-line "^#\\+\\(\\w*\\)" 1)
                       t)))
    (candidates (mapcar #'upcase
                        (cl-remove-if-not
                         (lambda (c) (string-prefix-p arg c))
                         (pcomplete-completions))))
    (ignore-case t)
    (duplicates t)))
#+END_SRC
* Org-mode

** Core package

I use ~use-package~ to load ~org-mode~, but, to make it easier to annotate, I split other aspects of the configuration out into their own blocks.

Note that this is loaded /after/ ~citeproc-org~ because that has to add hooks before org-mode is loaded.
Otherwise, I have to manually reload Org to get ~citeproc-org~ to work.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure t
  :config
  (require 'ox-md))
#+END_SRC

** Agenda files

I keep my core org files backed up using Dropbox.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/Dropbox/Notes/" "~/Dropbox/references/notes.org"))
#+END_SRC

I have my core org-mode files organized as follows:
- unsorted.org :: Unsorted notes that automatically have the ~REFILE~ tag and show up in my custom agenda view. The goal is to keep this file empty.
- orgzly.org :: Similar to above, but limited to things I save from the "orgzly" app on my Android phone.
- work.org :: Notes related to work. This is broken down as follows:
              + Projects :: Manuscripts, proposals, etc. that I am working on
                            - Top-level headers for each projects, as well as...
                            - Project ideas :: Random, unstructured ideas for future projects. As these solidify, they should be moved into top-level headers.
              + Conferences :: Everything related to academic conferences, meetings, workshops, etc.
              + Job applications :: Notes related to past, present, and future job applications
              + Opportunities :: Possible places to work, research funding sources, etc.
              + Teaching :: Notes related to any kind of teaching
              + Work habits :: Work-related things I should be doing on a regular basis. Most important are reading literature and writing.
- computers.org :: Notes and tasks related to programming, software, etc. Small tasks related to "sharpening the knife" (e.g. tweaking configurations) are organized in here.
                   + Organization :: Default TODO for time logging. Also, notes related to how I am organized.
                   + R :: Things related to R programming.
                   + LaTeX :: Things related to writing in LaTeX, including beamer presentations
                   + Emacs :: Things related to my text editor, including configuration to-dos
                   + Unix :: Things related to Unix in general, including shells (bash, zsh), various utilities (awk, grep, ssh), and anything related to Linux configuration.
                   + Miscellaneous programming :: Other stuff related to programming
- life.org :: Notes and tasks that are not work-related, organized as follows:
              - Chores :: Chores that need to get done
              - Events :: Upcoming life/personal events
              - Music :: Things related to my music hobbies
              - Personal notes :: Random notes-to-self
              - Personal habits :: Non work-related things I should be doing regularly.

                   #+BEGIN_SRC emacs-lisp
(defun ans/clean-org-agenda-files ()
  "Remove org agenda files that don't exist."
  (interactive)
  (setq org-agenda-files (-filter 'file-exists-p (org-agenda-files))))

(ans/clean-org-agenda-files)

;; Custom source listing all agenda files
(defun ans/helm-org-agenda-list-files ()
  "Helm source listing all current org agenda files."
  (interactive)
  (helm :sources (helm-build-sync-source
                     "Org agenda files"
                   :candidates (org-agenda-files)
                   :action '(("Open file" . find-file)))
        :buffer "*helm agenda files*"))
                   #+END_SRC

** Agenda views

Exclude the following tags from inheritance.
This will make it easier to exclude top level headers from Agenda views.

#+BEGIN_SRC emacs-lisp
(setq org-tags-exclude-from-inheritance '("_project" "_organize"))
#+END_SRC

Toggle showing scheduled/deadline tasks in the default agenda view (by default, don't show these tasks).
This is nice because tasks scheduled for some point in the future shouldn't take up room in my to-do list.

#+BEGIN_SRC emacs-lisp
(setq ans/hide-scheduled-tasks t)
(setq org-agenda-tags-todo-honor-ignore-options t)

(defun ans/toggle-show-scheduled-tasks ()
  "Toggle display of scheduled/deadline tasks in agenda."
  (interactive)
  (setq ans/hide-scheduled-tasks (not ans/hide-scheduled-tasks))
  (when (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s SCHEDULED/DEADLINE tasks" (if ans/hide-scheduled-tasks "Hide" "Show")))
#+END_SRC

Define the custom agenda views.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '((" " "Agenda"
	 ((agenda "" nil)
	  (tags "REFILE"
		((org-agenda-overriding-header "Notes to Refile")
		 (org-tags-match-list-sublevels nil)))
	  (tags-todo "-REFILE-config-reading_list-_project-_organization/NEXT!"
		     ((org-agenda-overriding-header
                       (concat "Next tasks" (if ans/hide-scheduled-tasks "" " (including scheduled)")))
		      (org-agenda-todo-ignore-scheduled ans/hide-scheduled-tasks)
		      (org-agenda-sorting-strategy '(priority-down))))
          (tags-todo "forte-_project/-NEXT!"
                     ((org-agenda-overriding-header
                       (concat "FoRTE" (if ans/hide-scheduled-tasks "" " (including scheduled)")))
                      (org-agenda-todo-ignore-scheduled ans/hide-scheduled-tasks)
                      (org-agenda-sorting-strategy '(priority-down))))
          (tags-todo "hector-_project/-NEXT!"
                     ((org-agenda-overriding-header
                       (concat "Hector" (if ans/hide-scheduled-tasks "" " (including scheduled)")))
                      (org-agenda-todo-ignore-scheduled ans/hide-scheduled-tasks)
                      (org-agenda-sorting-strategy '(priority-down))))
          (tags-todo "pecan-_project/-NEXT!"
                     ((org-agenda-overriding-header
                       (concat "PEcAn" (if ans/hide-scheduled-tasks "" " (including scheduled)")))
                      (org-agenda-todo-ignore-scheduled ans/hide-scheduled-tasks)
                      (org-agenda-sorting-strategy '(priority-down))))
	  (tags-todo "-REFILE-config-reading_list-_project-_organization-forte-hector-pecan/-NEXT!"
		     ((org-agenda-overriding-header (concat "Other tasks"
							    (if ans/hide-scheduled-tasks
								""
							      " (including scheduled)")))
		      (org-agenda-sorting-strategy '(todo-state-down priority-down))
		      (org-agenda-todo-ignore-deadlines ans/hide-scheduled-tasks))))
	 nil)
	("r" "Reading list" todo "TODO|NEXT"
	 ((org-agenda-files '("~/Dropbox/references/notes.org"))
	  (org-agenda-sorting-strategy '(todo-state-down priority-down))))
	("c" "Configuration" tags-todo "-_organization-_project"
	 ((org-agenda-files '("~/Dropbox/Notes/computers.org"))
	  (org-agenda-sorting-strategy '(todo-state-down priority-down))))
	("p" "Projects" tags-todo "_project"
	 ((org-agenda-sorting-strategy '(todo-state-down))))))
#+END_SRC

Some custom keybindings for org agenda mode.

#+BEGIN_SRC emacs-lisp
(general-def
  :states 'motion
  :keymaps 'org-agenda-mode-map
  "gl" 'org-agenda-log-mode
  "ga" 'ans/org-agenda-toggle-archive
  "gwd" 'org-agenda-day-view
  "gww" 'org-agenda-week-view
  "gwm" 'org-agenda-month-view
  "@" 'ans/toggle-show-scheduled-tasks)
#+END_SRC

This is the function for toggling display of archived entries in agenda.

#+BEGIN_SRC emacs-lisp
(defun ans/org-agenda-toggle-archive ()
  "Toggle showing archived entries in agenda mode."
  (interactive)
  (if org-agenda-archives-mode
      (progn (setq org-agenda-archives-mode nil)
             (message "Agenda archive mode disabled."))
    (setq org-agenda-archives-mode t)
    (message "Agenda archive mode enabled."))
  (org-agenda-redo))
#+END_SRC

Configure priorities.
The three priority levels are high (A, 65), normal (B, 66), and low (C, 67).
Tasks without a priority default to the normal (B) priority.
My agenda places higher-priority tasks at the top and lower-priority tasks at the bottom.

#+BEGIN_SRC emacs-lisp
(setq org-priority-start-cycle-with-default t
      org-default-priority 66
      org-highest-priority 65
      org-lowest-priority 67)
#+END_SRC

Use the current buffer for the agenda window.
The default (~reorganize-frame~) blows up my existing window configuration, which is annoying.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'current-window)
#+END_SRC

Indent nested agenda items with dots:

#+BEGIN_SRC emacs-lisp
(setq org-tags-match-list-sublevels 'indented)
#+END_SRC

** Org capture

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("E" "Emacs config" entry
         (file+headline "~/Dropbox/Notes/computers.org" "TODO Emacs configuration")
         "** TODO %?" :clock-in t :clock-resume t)
        ("e" "Emacs note" entry
         (file+headline "~/Dropbox/Notes/computers.org" "Emacs")
         "** %?" :clock-in t :clock-resume t)
        ("t" "TODO" entry
         (file "~/Dropbox/Notes/unsorted.org")
         "* TODO %?\nCaptured %U\nFrom file %a\n" :clock-in t :clock-keep t)
        ("l" "Later TODO" entry
         (file "~/Dropbox/Notes/unsorted.org")
         "* TODO %?\nCaptured %U\nFrom file %a\n" :clock-in t :clock-resume t)
        ("u" "Miscellaneous note" entry
         (file "~/Dropbox/Notes/unsorted.org")
         "* %? :NOTE:\nCaptured %U\n%a\n" :clock-in t :clock-resume t)
        ("i" "Interruption" entry (file "~/Dropbox/Notes/unsorted.org")
         "* %? \nCaptured %U" :clock-in t :clock-resume t)
        ("s" "Schedule event" entry (file "~/Dropbox/Notes/unsorted.org")
         "* %^{Event}t %? :NOTE:\nCaptured %U" :clock-in t :clock-resume t)))
#+END_SRC

*** org-capture-pop-frame

Run ~org-capture~ in its own frame.
This is temporarily disabled because it interferes with ~perspective~ in some edge cases.

#+BEGIN_SRC emacs-lisp
(use-package org-capture-pop-frame
  :disabled
  :ensure t)
#+END_SRC

** Default to-do keywords

All my org files have these to-do keywords by default.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "|" "DONE" "CANCELED")))
#+END_SRC

However, these can be set on a file-specific basis as well via the ~#+TODO~ property.

#+BEGIN_EXAMPLE
#+TODO: TODO FEEDBACK VERIFY | DONE CANCELLED
#+END_EXAMPLE

** Formatting and aesthetics

Show emphasis markers by default, but also quickly toggle them with a custom function.

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers nil)

(defun ans/org-toggle-emphasis-markers ()
  "Toggle the display of org emphasis markers."
  (interactive)
  (if org-hide-emphasis-markers
      (setq org-hide-emphasis-markers nil)
    (setq org-hide-emphasis-markers t))
  (font-lock-flush))
#+END_SRC

By default, hide line numbers in org-mode buffers, and disable adaptive prefix mode.

#+BEGIN_SRC emacs-lisp
(defun ans/org-mode-settings ()
  "Custom settings for org mode."
  (linum-mode -1)
  (adaptive-wrap-prefix-mode -1))

(add-hook 'org-mode-hook 'ans/org-mode-settings)
#+END_SRC

By default, use org-mode indentation.

#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
#+END_SRC

Automatically re-indent a source code block.

#+BEGIN_SRC emacs-lisp
(defun ans/indent-org-source-block ()
  "Re-indent an org mode source code block."
  (interactive)
  (when (org-in-src-block-p)
    (org-edit-special)
    (indent-region (point-min) (point-max))
    (org-edit-src-exit)))
#+END_SRC

Don't reposition the screen when expanding an outline.
Note that the cursor can be repositioned at the center of the screen with =zz=.

#+BEGIN_SRC emacs-lisp
(remove-hook 'org-cycle-hook #'org-optimize-window-after-visibility-change)
#+END_SRC

End of line should ignore tags.

#+BEGIN_SRC emacs-lisp
(setq org-special-ctrl-a/e t)
#+END_SRC

** Source code (babel)

Automatically fontify source code, and edit source code in the current window (rather than opening a new one).

#+BEGIN_SRC emacs-lisp
(setq org-babel-load-languages '((emacs-lisp . t) (R . t))
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-window-setup 'other-window
      org-src-preserve-indentation t)

(set-face-attribute 'org-block nil :foreground nil :background "Gray15")
(set-face-attribute 'org-block-begin-line nil :background "#001436")

(condition-case ans/babel-error
    (with-eval-after-load 'org
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t) (R . t))))
  ((debug error) (message "Failed with error %s" ans/babel-error)))
#+END_SRC

Don't prompt for confirmation on babel evaluation.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

Set some language-specific default settings.

#+BEGIN_SRC emacs-lisp
(defvar org-babel-default-header-args:R '((:session . "*org-R*")))
#+END_SRC

** Refile

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9))
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm
      org-refile-target-verify-function 'ans/verify-refile-target)

(defun ans/verify-refile-target ()
  "Exclude TODO keywords with a done state from refile targets."
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
#+END_SRC

** Clocking

Use the clocking settings from "Organize your life in plain text".

#+BEGIN_SRC emacs-lisp
(setq
 ;; Resume clocking task on clock in if it's already open
 org-clock-in-resume t
 ;; Separate drawers for clocking and logs
 org-drawers '("PROPERTIES" "LOGBOOK")
 ;; Save clock data and state changes and notes in LOGBOOK drawer
 org-clock-into-drawer t
 ;; Remove clocks with 0:00 duration
 org-clock-out-remove-zero-time-clocks t
 ;; Clock out when marking a task as DONE
 org-clock-out-when-done t
 ;; Save running clock and clock history when exiting emacs; reload on startup
 ;; See org-clock-persistence-insinuate below
 org-clock-persist t
 ;; Do not prompt to resume an active clock
 org-clock-persist-query-resume nil
 ;; Auto-clock resolution for finding open clocks
 org-clock-auto-clock-resolution (quote when-no-clock-is-running)
 ;; Include current clocking task in clock reports
 org-clock-report-include-clocking-task t
 ;; Show current clock time in frame title
 org-clock-mode-line-total 'current
 org-clock-clocked-in-display 'mode-line
 org-clock-history-length 10)

(org-clock-persistence-insinuate)
#+END_SRC

When clocking out of a task, automatically clock into the parent task

#+BEGIN_SRC emacs-lisp
(defun ans/clock-out-maybe ()
  "Clock parent task, or clock out."
  (when (and ans/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (ans/clock-in-parent-task)))

(defun ans/clock-in-parent-task ()
  "Move point to parent task (if any) and clock in.
  Otherwise, clock in the default task."
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when ans/keep-clock-running
            (ans/clock-in-organization-task)))))))

(add-hook 'org-clock-out-hook #'ans/clock-out-maybe 'append)
#+END_SRC

Default settings for a clocktable.

#+BEGIN_SRC emacs-lisp
(setq org-clock-clocktable-default-properties
      '(:maxlevel 5 :scope agenda-with-archives :block today :link t)
      org-agenda-clockreport-parameter-plist
      '(:maxlevel 5 :link t))
#+END_SRC

*** Clocking functions

Clock into a default task ("organization").

#+BEGIN_SRC emacs-lisp
(defun ans/punch-in ()
  "Start clocking, and set default task to Organization."
  (interactive)
  (setq ans/keep-clock-running t)
  (ans/clock-in-organization-task))

(defun ans/punch-out ()
  "End all clocking."
  (interactive)
  (setq ans/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Default clocking task ("organization") ID
(defvar ans/organization-task-id "b86713a1-f9db-47c5-860f-6a2aecfec6c9")
(defun ans/clock-in-organization-task ()
  "Clock in the default organization task."
  (interactive)
  (org-with-point-at (org-id-find ans/organization-task-id 'marker)
    (org-clock-in '(16))))
#+END_SRC

** Custom structure templates

These are expanded by typing ~<~ followed by the character(s) and then ~TAB~.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist
             '("p" ":PROPERTIES:\n?\n:END:"))
#+END_SRC

** Org-mode keybindings

#+BEGIN_SRC emacs-lisp
(general-def
  :states '(normal insert)
  :keymaps 'org-mode-map
  "C-c C-q" 'org-set-tags
  "M-l" 'org-metaright
  "M-S-l" 'org-demote-subtree
  "M-h" 'org-metaleft
  "M-S-l" 'org-promote-subtree
  "<C-M-return>" 'org-insert-subheading)

(general-def
  :states '(motion normal)
  :keymaps 'org-mode-map
  "<backspace>" 'outline-hide-subtree
  "gh" 'org-up-element
  "gl" 'org-down-element
  "gt" 'org-todo
  "g$" 'evil-end-of-line
  "g%" 'ans/org-realign-tags
  "go" 'ans/evil-insert-heading-after-current
  "gO" 'ans/evil-insert-heading)

(general-def
  :states 'visual
  :keymaps 'org-mode-map
  :prefix "\\"
  "ss" 'eval-region)

(general-def
  :states 'normal
  :keymaps 'org-mode-map
  :prefix "\\"
  "e" 'org-edit-special
  "k" 'org-export-dispatch
  "RET" 'org-ctrl-c-ctrl-c
  "=" 'ans/indent-org-source-block
  "TAB" 'ans/org-hide-all-except-current)

(general-def
  :states 'insert
  :keymaps 'org-mode-map
  "C-=" '(lambda () (interactive)(insert "#+"))
  "C-/" 'org-toggle-checkbox
  "C--" 'org-toggle-item
  "C-." 'org-cycle-list-bullet
  "C-," '(lambda () (interactive) (org-cycle-list-bullet 'previous)))

(general-def
  :states '(motion normal emacs)
  :keymaps 'org-mode-map
  :prefix "SPC"
  "#" 'org-update-statistics-cookies
  "%" 'ans/org-toggle-emphasis-markers)

(general-def
  :states '(motion normal visual)
  :keymaps 'org-mode-map
  :prefix "SPC"
  "ss" 'org-schedule
  "sd" 'org-deadline)

(general-def
  :states '(motion)
  :keymaps 'calendar-mode-map
  "h" 'calendar-backward-day
  "l" 'calendar-forward-day
  "k" 'calendar-backward-week
  "j" 'calendar-forward-week
  "H" 'calendar-backward-month
  "L" 'calendar-forward-month)
#+END_SRC

*** evil-org

#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :ensure t
  :after org
  :config
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook 'ans/evil-org-mode-setup)
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))

(defun ans/evil-org-mode-setup ()
  "Custom setup for org mode."
  (push '(?* . ("*" . "*")) evil-surround-pairs-alist)
  (push '(?/ . ("/" . "/")) evil-surround-pairs-alist)
  (evil-org-set-key-theme '(navigation insert textobjects calendar)))
#+END_SRC

** Other custom functions

#+BEGIN_SRC emacs-lisp
(defun ans/evil-insert-heading ()
  "Insert heading before point and enter insert mode."
  (interactive)
  (org-insert-heading)
  (evil-insert 1))

(defun ans/evil-insert-heading-after-current ()
  "Insert heading after point and enter insert mode."
  (interactive)
  (org-insert-heading-respect-content)
  (evil-insert 1))

(defun ans/org-realign-tags ()
  "Right-align org mode tags in current buffer."
  (interactive)
  (org-set-tags nil t))

(defun air--org-swap-tags (tags)
  "Replace any tags on the current headline with TAGS.

  The assumption is that TAGS will be a string conforming to Org Mode's
  tag format specifications, or nil to remove all tags."
  (let ((old-tags (org-get-tags-string))
        (tags (if tags
                  (concat " " tags)
                "")))
    (save-excursion
      (beginning-of-line)
      (re-search-forward
       (concat "[ \t]*" (regexp-quote old-tags) "[ \t]*$")
       (line-end-position) t)
      (replace-match tags)
      (org-set-tags t))))

(defun air-org-set-tags (tag)
  "Add TAG if it is not in the list of tags, remove it otherwise.

  TAG is chosen interactively from the global tags completion table."
  (interactive
   (list (let ((org-last-tags-completion-table
                (if (derived-mode-p 'org-mode)
                    (org-uniquify
                     (delq nil (append (org-get-buffer-tags)
                                       (org-global-tags-completion-table))))
                  (org-global-tags-completion-table))))
           (completing-read
            "Tag: " 'org-tags-completion-function nil nil nil
            'org-tags-history))))
  (let* ((cur-list (org-get-tags))
         (new-tags (mapconcat 'identity
                              (if (member tag cur-list)
                                  (delete tag cur-list)
                                (append cur-list (list tag)))
                              ":"))
         (new (if (> (length new-tags) 1) (concat " :" new-tags ":")
                nil)))
    (air--org-swap-tags new)))

(defun ans/org-hide-all-except-current ()
  "Close all subtrees outside of the current view."
  (interactive)
  (save-excursion
    (org-global-cycle))
  (org-cycle))

(defun ans/org-agenda-mode-p ()
  "Boolean to check if currently in agenda mode."
  (equal major-mode 'org-agenda-mode))
#+END_SRC

** org-journal

#+BEGIN_SRC emacs-lisp
(use-package org-journal
  :disabled
  :init
  (setq org-journal-dir "~/Dropbox/Notes/journal"
        org-journal-file-format "%Y-%m-%d"
        org-journal-enable-agenda-integration t))
(evil-ex-define-cmd "now" 'org-journal-new-entry)
#+END_SRC
** toc-org

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :ensure t
  :config
  (add-hook 'org-mode-hook 'toc-org-enable))
#+END_SRC
** org-ref

#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :ensure t
  :init
  (setq org-ref-bibliography-notes ans/reference-notes
        reftex-default-bibliography `(,ans/reference-bibfile)
        org-ref-default-bibliography `(,ans/reference-bibfile)
        org-ref-pdf-directory ans/reference-dir-pdfs
        org-ref-bibtex-hydra-key-binding nil
        org-ref-note-title-format
        "** TODO %2a %y - %T
:PROPERTIES:
:Custom_ID: %k
:AUTHOR: %9a
:FULL_TITLE: %t
:JOURNAL: %j
:YEAR: %y
:VOLUME: %v
:PAGES: %p
:DOI: %D
:URL: %U
:END:
")
  (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
  :general
  (general-def
    :states 'normal
    "\\\\" 'org-ref-bibtex-hydra/body)
  (general-def
    :states 'insert
    "C-\\" 'org-ref-bibtex-hydra/body)
  (general-def
    :keymaps 'org-ref-bibtex-hydra/keymap
    "n" '(lambda ()(interactive) (org-ref-open-bibtex-notes) (hydra-keyboard-quit)))
  (general-def
    :states 'normal
    :keymaps 'bibtex-mode-map
    :prefix "\\"
    "d" 'doi-insert-bibtex
    "D" '(lambda () (interactive) (doi-insert-bibtex (simpleclip-get-contents)))))
#+END_SRC
** citeproc-org

Note that this is lazily loaded when ~citeproc-org-setup~ is called.
Note also that loading this package triggers ~org-reload~.

#+BEGIN_SRC emacs-lisp
(use-package citeproc-org
  :quelpa (citeproc-org :fetcher github :repo "andras-simonyi/citeproc-org")
  :commands citeproc-org-setup
  :init
  (setq citeproc-org-ignore-backends nil)
  :config
  (citeproc-org-setup)
  (org-reload))
#+END_SRC
** Hydras for org mode tasks

*** Main org-mode hydra

#+BEGIN_SRC emacs-lisp
(defhydra ans/org-mode-hydra (:exit t)
  "Org mode"
  ("a" org-agenda "Agenda")
  ("o" org-capture "Capture")
  ("r" ans/org-refile-aware "Refile")
  ("s" org-search-view "Search")
  ("?" helm-org-rifle-agenda-files "Helm search")
  ("/" helm-org-rifle-current-buffer "Search current")
  ("f" ans/helm-org-agenda-list-files "List agenda files")
  ("l" org-store-link "Store link")
  ("L" org-insert-last-stored-link "Insert stored link")
  ("n" ans/org-toggle-narrow "Toggle narrow")
  ("N" org-narrow-to-subtree "Narrow")
  ("0" widen "Widen")
  ("e" org-edit-special "Edit special")
  ("E" org-export-dispatch "Export")
  ("c" ans/clock-hydra/body "Clocking")
  ("t" ans/org-scheduling-hydra/body "Scheduling")
  ("b" ans/org-babel-hydra/body "Babel")
  ("S" org-save-all-org-buffers "Save all buffers")
  ("x" ans/make-org-scratch "Open scratch")
  ("DEL" org-archive-subtree-default "Archive")
  ("!" org-reload "Reload")
  ("&" org-toggle-pretty-entities "Toggle pretty math")
  ("<tab>" org-reveal "Reveal")
  ("SPC" org-ctrl-c-ctrl-c "C-c")
  ("=" org-toggle-latex-fragment "Preview LaTeX"))

(defun ans/org-refile-aware ()
  "Context-aware org refile."
  (interactive)
  (cond ((ans/org-agenda-mode-p) (org-agenda-refile))
	((bound-and-true-p org-capture-mode) (org-capture-refile))
	(t (org-refile))))

(defun ans/org-toggle-narrow ()
  "Narrow if widened, otherwise widen."
  (interactive)
  (if (buffer-narrowed-p)
      (widen)
    (org-narrow-to-subtree)))

(defun ans/make-org-scratch ()
  "Open an org-mode scratch buffer."
  (interactive)
  (find-file "/tmp/publish/scratch.org")
  (gnus-make-directory "/tmp/publish"))
#+END_SRC

*** Hydra for clocking

#+BEGIN_SRC emacs-lisp
(defhydra ans/clock-hydra (:exit t)
  "Clocking commands."
  ("RET" org-clock-in "Clock in")
  ("<backspace>" org-clock-out "Clock out")
  ("+" ans/punch-in "Punch in")
  ("-" ans/punch-out "Punch out")
  ("g" org-clock-goto "Go to current clock")
  ("l" org-clock-in-last "Go to most recent clock")
  ("h" (org-clock-in-last '(4)) "Clock from history")
  ("r" org-clock-report "Insert clock report")
  ("<up>" org-clock-timestamps-up "Adjust time up")
  ("<down>" org-clock-timestamps-down "Adjust time down"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defhydra ans/org-scheduling-hydra (:exit t)
  "Deadlines and scheduling."
  ("d" ans/org-deadline-aware "Deadline")
  ("s" ans/org-schedule-aware "Schedule"))

(defun ans/org-deadline-aware (arg)
  "Context-aware org-deadline."
  (interactive "P")
  (if (ans/org-agenda-mode-p)
      (call-interactively 'org-agenda-deadline)
    (org-deadline arg)))

(defun ans/org-schedule-aware (arg)
  "Context-aware org-schedule."
  (interactive "P")
  (if (ans/org-agenda-mode-p)
      (call-interactively 'org-agenda-schedule)
    (org-schedule arg)))
#+END_SRC

*** Hydra for org-babel

#+BEGIN_SRC emacs-lisp
(defhydra ans/org-babel-hydra (:exit t)
  "org-babel"
  ("t" org-babel-tangle "tangle")
  ("T" org-table-export "export table")
  ("-" org-babel-demarcate-block "split block")
  ("r" org-babel-execute-subtree "run subtree")
  ("R" org-babel-execute-buffer "run buffer")
  ("g" org-babel-goto-named-src-block "goto block")
  ("G" org-babel-goto-named-result "goto result")
  ("SPC" org-babel-goto-src-block-head "block head")
  ("F" org-babel-tangle-jump-to-org "jump to org file")
  ("s" org-babel-switch-to-session "session")
  ("S" org-babel-switch-to-session-with-code "session with code"))
#+END_SRC

** Github-flavored markdown

#+BEGIN_SRC emacs-lisp
(use-package ox-gfm
  :ensure t
  :after org)
#+END_SRC

** Habits

Load the habits module.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-modules 'org-habit)
#+END_SRC

For now, don't show habits in the agenda view.
I still need to set this up.

#+BEGIN_SRC emacs-lisp
(setq org-habit-show-habits nil)
#+END_SRC

** Convert org-mode table to format in place

Instead of creating a new file, just replace the current table.
Sourced from [[https://gist.github.com/ShingoFukuyama/7887053][this GitHub gist]].

#+BEGIN_SRC emacs-lisp
(defun ans/get-string-from-file (file-path)
  "Return contents of FILE-PATH as a string."
  (with-temp-buffer
    (insert-file-contents file-path)
    (buffer-string)))

(defun ans/org-table-convert-replace ()
  "Convert org table to CSV in place"
  (interactive)
  (unless (org-at-table-p) (user-error "No table at point"))
  (let* ((target-file (make-temp-file "orgtbl"))
	 (beg (org-table-begin))
	 (end (org-table-end)))
    (org-table-export target-file "orgtbl-to-csv")
    (delete-region beg end)
    (insert-file-contents target-file)))
#+END_SRC

** Remove headlines but keep content

Use org mode outline for organization, but hide this organization from exported documents.

#+BEGIN_SRC emacs-lisp
(defun ans/org-remove-headlines (backend)
  "Remove headlines with :no_title tag."
  (org-map-entries (lambda () (delete-region (point-at-bol) (point-at-eol)))
		   "no_title"))

(add-hook 'org-export-before-processing-hook #'ans/org-remove-headlines)
#+END_SRC
** Remove link (but keep description)

Basically, replace a link with its description.
Based on [[https://emacs.stackexchange.com/a/10714/19378][this SO answer]].

#+BEGIN_SRC emacs-lisp
(defun ans/org-replace-link-by-link-description ()
  "Replace an org link by its description or if empty its address"
  (interactive)
  (if (org-in-regexp org-bracket-link-regexp 1)
      (let ((remove (list (match-beginning 0) (match-end 0)))
            (description (if (match-end 3) 
                             (org-match-string-no-properties 3)
                           (org-match-string-no-properties 1))))
        (apply 'delete-region remove)
        (insert description))))

(general-def
  :keymaps 'org-mode-map
  :states 'normal
  "C-c C-." #'ans/org-replace-link-by-link-description)
#+END_SRC
* yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (setq yas-snippet-dirs '("~/.emacs.d/snippets")
	yas-visit-from-menu t)
  :config
  (yas-reload-all)
  (yas-global-mode 1)
  ;; Use something like this if you don't want snippets globally:
  ;; (yas-reload-all)
  ;; (add-hook 'prog-mode-hook #'yas-minor-mode)
  (general-def
    :keymaps 'yas-minor-mode-map
    "<escape>" 'yas-exit-snippet)
  (ans-leader-def
    :states '(motion normal)
    "un" 'yas-new-snippet
    "ue" 'yas-visit-snippet-file
    "ur" 'yas-reload-all))
#+END_SRC
* ESS -- Emacs Speaks Statistics

** ESS core configuration

#+BEGIN_SRC emacs-lisp
(use-package ess
  :ensure t
  :mode ("\\.[rR]\\'" . r-mode)
  :config
  (require 'ess-rutils)
  (setq comint-move-point-for-output t)	; Scroll R buffer on output
  (setq inferior-R-args "--no-save --no-restore"
        ess-ask-for-ess-directory nil
        ess-directory-function 'ans-r-file-here
        ess-own-style-list '((ess-indent-offset . 2)
                             (ess-offset-arguments . open-delim)
                             (ess-offset-arguments-newline . prev-call)
                             (ess-offset-block . prev-line)
                             (ess-align-continuations-in-calls . t)
                             (ess-indent-with-fancy-comments . nil))
        ess-default-style 'RStudio
        ess-use-company t
        ess-eval-visibly 'nowait)
  ;; Disable flymake. Use flycheck instead.
  (setq ess-use-flymake nil)
  (setq ess-roxy-str "#'"
	ess-roxy-fill-param-p t
	ess-roxy-template-alist
	'(("description" . ".. title/description ..")
	  ("param" . "")
	  ("return" . "")
	  ("author" . "Alexey Shiklomanov")))
  (setf (alist-get 'ess-fl-keyword:fun-calls ess-R-font-lock-keywords) t)
  (ans/add-evil-maps 'ess-help-mode-map)
  (add-to-list 'display-buffer-alist `("*R" (display-buffer-reuse-window
                                             display-buffer-same-window)))
  ;; Temporarily disable because of bug
  ;; See emacs-ess/ESS issue #720
  (setq ess-use-tracebug nil)
  (general-def
    :keymaps 'ess-mode-map
    :states 'normal
    :prefix "\\"
    "r f" #'ans-start-R
    "r q" #'ans-quit-R
    "l" #'ans/r-send-line
    "d" #'ans/r-send-line-and-down
    "f f" #'ans/r-send-function-or-paragraph
    "p p" #'ans/r-send-paragraph
    "p d" #'ans/r-send-paragraph-and-down
    "a a" #'ans/r-send-buffer
    "a d" #'ans/r-send-current-line-to-end
    "a s" #'ans/r-send-beginning-to-current-line
    "SPC" #'ess-eval-region-or-function-or-paragraph
    "RET" #'ess-eval-region-or-function-or-paragraph-and-step
    "v i" #'ess-r-devtools-install-package
    "v d" #'ess-r-devtools-document-package
    "v l" #'ess-r-devtools-load-package
    "v t" #'ess-r-devtools-test-package
    "v c" #'ess-r-devtools-check-package
    "r h" #'ess-display-help-on-object
    "r o" #'ess-rutils-objs
    "r p" #'ans/ess-eval-symbol
    "r g" #'ans/ess-glimpse-symbol
    "r s" #'ans/ess-str
    "r z" #'ans/ess-symbol-size
    "r n" #'ans/ess-names
    "k r" #'ans/rmarkdown-render
    "r H" #'ans/ess-head
    "r T" #'ans/ess-tail
    "x " #'ess-interrupt
    "X" #'ans/ess-dev-off
    "o p" #'ans/ess-plot-symbol-scatter
    "o l" #'ans/ess-plot-symbol-line
    "O p" #'ans/ess-matplot-symbol-points
    "O l" #'ans/ess-matplot-symbol-lines
    "!" #'ans/ess-toggle-debug
    "z p" #'ans/ess-usethis-package
    "r l" #'ans/ess-drake-loadd
    "r d" #'ans/ess-drake-readd
    "r i" (lambda (arg) (interactive "P") (ans/import/add-to-imports arg) (ans/import/source-imports)))
  (general-def
    :keymaps 'ess-mode-map
    "M-RET" 'ess-newline-and-indent)
  (general-def
    :states 'visual
    :keymaps 'ess-mode-map
    :prefix "\\"
    "s s" 'ans/r-send-region-source
    "r x" 'ans/ess-reprex-region
    "=" #'ans/ess-tidy-region)
  (general-def
    :states 'insert
    :keymaps 'inferior-ess-mode-map
    "_" 'self-insert-command
    "M--" 'ess-insert-assign)
  (general-def
    :states 'insert
    :keymaps 'ess-mode-map
    "_" 'self-insert-command
    "M-m" (lambda() (interactive)(insert " %>%"))
    "M--" 'ess-insert-S-assign
    "C-c" (lambda() (interactive)(insert "#'"))
    "C-8" (lambda() (interactive)(insert " %*% "))
    "C-+" '(lambda () (interactive) (insert "#########################################\n")))
  (general-def
    :keymaps 'ess-help-mode-map
    :states 'emacs
    "SPC" 'ans-leader-command)
  (general-def
    :keymaps 'ess-help-mode-map
    :states 'emacs
    :prefix "\\"
    "r h" 'ess-display-help-on-object)
  (general-def
    :keymaps 'ess-rdired-mode-map
    "j" 'ess-rdired-next-line
    "k" 'ess-rdired-previous-line))

(defun ans/inferior-ess-mode-setup ()
  "My custom configuration for inferior-ess-mode."
  (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions)))

(defun ans/ess-r-mode-setup ()
  "My custom configuration for ess-r-mode."
  (ess-set-style 'RStudio 'quiet))

(add-hook 'inferior-ess-mode-hook 'ans/inferior-ess-mode-setup)
(add-hook 'ess-r-mode-hook 'ans/ess-r-mode-setup)
#+END_SRC

** Send region using R "source" function

#+BEGIN_SRC emacs-lisp
(defun ans/r-send-region-source (start end)
  "Send region from START to END to R using source function."
  (interactive "r")
  (let* ((code (buffer-substring-no-properties start end))
         (nlines (count-lines start end)))
    (ess-send-string
     (ess-get-process)
     (format "
.esstmpfile <- tempfile()
.essstring <- readLines(con = stdin(), n = %d)
%s
writeLines(.essstring, .esstmpfile)
source(.esstmpfile, echo = TRUE)
" nlines code))))

(defun ans/r-send-line ()
  "Send current line to R."
  (interactive)
  (ans/r-send-region-source (line-beginning-position) (line-end-position)))

(defun ans/r-send-buffer ()
  "Send entire current buffer to R."
  (interactive)
  (ans/r-send-region-source (point-min) (point-max)))

(defun ans/r-send-beginning-to-current-line ()
  "Run from beginning of buffer through end of current line."
  (interactive)
  (ans/r-send-region-source (point-min) (line-end-position)))

(defun ans/r-send-current-line-to-end ()
  "Run from beginning of current line to end of buffer."
  (interactive)
  (ans/r-send-region-source (line-beginning-position) (point-max)))

(defun ans/r-send-function-or-paragraph ()
  "Send current function definition."
  (interactive)
  (save-excursion
    (ess-mark-function-or-para)
    (ans/r-send-region-source (point) (mark))
    (deactivate-mark)))

(defun ans/r-send-paragraph ()
  "Send current paragraph."
  (interactive)
  (save-excursion
    (mark-paragraph)
    (ans/r-send-region-source (point) (mark))
    (deactivate-mark)))

(defun ans/r-send-paragraph-and-down ()
  "Send current paragraph."
  (interactive)
  (save-excursion
    (mark-paragraph)
    (ans/r-send-region-source (point) (mark))
    (deactivate-mark))
  (evil-forward-paragraph))

(defun ans/r-send-line-and-down ()
  "Send current line to R and advance one line down."
  (interactive)
  (ans/r-send-line)
  (ess-next-code-line))

(defun ans/r-send-function-or-para-and-down ()
  "Send current function or paragraph and advance one line."
  (interactive)
  (ess-mark-function-or-para)
  (exchange-point-and-mark)
  (ans/r-send-region-source (mark) (point))
  (deactivate-mark)
  (ess-next-code-line))

(defun ans/ess-tidy-region (start end)
  "Run formatr::tidy_source() on REGION."
  (interactive "r")
  (let* (tmp fixed)
    (setq tmp (make-temp-file "r-tidy"))
    (write-region start end tmp)
    (setq fixed (shell-command-to-string (format "Rscript -e 'formatR::tidy_source(\"%s\", width.cutoff = 60)'" tmp)))
    (delete-region start end)
    (goto-char start)
    (insert fixed)
    (delete-trailing-whitespace start end)
    (indent-region start end)))
#+END_SRC

** Custom functions

*** Initialization helpers
#+BEGIN_SRC emacs-lisp
(defun ans-split-right-if-wide ()
  "Split the window to the right if there is sufficient space."
  (interactive)
  (let* ((width (window-total-width))
         (height (window-total-height))
         (want-width (round (* width -0.4)))
         (want-height (round (* height -0.4))))
    (if (< width (* height 2)) ;; was 140
        (split-window-below want-height)
      (split-window-right want-width))))

(defun ans-r-file-here ()
  "Use here::here to determine path for R buffer."
  (shell-command-to-string
   (concat
    "/usr/local/bin/Rscript -e \""
    "my_dir <- dirname('"(buffer-file-name)"');"
    "t <- tryCatch(setwd(my_dir), error = function(e) NULL);"
    "cat(here::here())"
    "\"")))

(defun ans-start-R ()
  "Start R with default options, splitting the window vertically."
  (interactive)
  (ans-split-right-if-wide)
  (other-window 1)
  (R)
  (other-window -1))
#+END_SRC

*** Quit and close window

#+BEGIN_SRC emacs-lisp
(defun ans-quit-R ()
  "Quit R process and close buffer."
  (interactive)
  (ess-quit 4))
#+END_SRC
*** Eval current symbol

#+BEGIN_SRC emacs-lisp
(defun ans/ess-eval-symbol ()
  "Evaluate (usually print) the symbol at point."
  (interactive)
  (save-excursion
    (er/mark-symbol)
    (ess-eval-region (point) (mark) nil)
    (deactivate-mark)))
#+END_SRC

*** Run command with symbol at point

#+BEGIN_SRC emacs-lisp
(defun ans/ess-do-with-symbol-at-point (command-string)
  "Run R expression in COMMAND-STRING using symbol-at-point."
  (ess-send-string
   (ess-get-process)
   (format command-string (symbol-at-point))))
#+END_SRC
*** ~dplyr::glimpse~

#+BEGIN_SRC emacs-lisp
(defun ans/ess-glimpse-symbol ()
  "Run 'dplyr::glimpse' on symbol at point."
  (interactive)
  (ess-send-string (ess-get-process) (format "dplyr::glimpse(%s)" (symbol-at-point))))
#+END_SRC

*** ~reprex::reprex~

#+BEGIN_SRC emacs-lisp
(defun ans/ess-reprex-region (start end venue)
  "Run the selection through `reprex::reprex', saving the output to the clipboard."
  (interactive "r\nsVenue (gh, so, ds, or r): ")
  (ess-send-string
   (ess-get-process)
   (format "reprex::reprex({%s}, venue = '%s', show = FALSE, advertise = FALSE)"
	   (buffer-substring-no-properties start end)
	   venue)))
#+END_SRC

*** ~Rcpp::compileAttributes()~

#+BEGIN_SRC emacs-lisp
(defun ans/ess-compile-attributes ()
  "Run ~Rcpp::compileAttributes~ on the package in the current directory."
  (interactive)
  (ess-send-string
   (ess-get-process)
   "Rcpp::compileAttributes()"))
#+END_SRC

*** Plot and matplot

#+BEGIN_SRC emacs-lisp
(defun ans/ess-plot-symbol-scatter ()
  "Do a base R scatter plot on the symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "plot(%s)"))

(defun ans/ess-plot-symbol-line ()
  "Do a base R plot on the symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "plot(%s, type = 'l')"))

(defun ans/ess-matplot-symbol-points ()
  "Do a matrix plot on the symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "matplot(%s)"))

(defun ans/ess-matplot-symbol-lines ()
  "Do a matrix plot on the symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "matplot(%s, type = 'l')"))
#+END_SRC
*** Size of symbol at point

#+BEGIN_SRC emacs-lisp
(defun ans/ess-symbol-size ()
  "Run 'pryr::object_size' on symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "pryr::object_size(%s)"))
#+END_SRC
*** Head and tail

#+BEGIN_SRC emacs-lisp
(defun ans/ess-head ()
  "Run 'base::head' on symbol at point."
  (interactive)
  (ess-send-string (ess-get-process) (format "head(%s)" (symbol-at-point))))

(defun ans/ess-tail ()
  "Run 'base::head' on symbol at point."
  (interactive)
  (ess-send-string (ess-get-process) (format "tail(%s)" (symbol-at-point))))
#+END_SRC
*** Toggle debug function

#+BEGIN_SRC emacs-lisp
(defun ans/ess-toggle-debug ()
  "Toggle debugging function at point."
  (interactive)
  (ess-send-string
   (ess-get-process)
   (format
    "if (isdebugged(%1$s)) {\n message('Undebug %1$s') \n undebug(%1$s) \n} else { \n message('Debug %1$s') \n debug(%1$s)}"
    (symbol-at-point))))
#+END_SRC
*** ~usethis~ utilities

#+BEGIN_SRC emacs-lisp
(defun ans/ess-usethis-package ()
  "Run `usethis::use_package` on symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "usethis::use_package('%s')"))
#+END_SRC
*** ~rmarkdown::render~

#+BEGIN_SRC emacs-lisp
(defun ans/rmarkdown-render ()
  "Render the current R markdown document."
  (interactive)
  (ess-send-string (ess-get-process) (format "rmarkdown::render('%s')" (buffer-file-name))))
#+END_SRC
*** ~drake~ functions

#+BEGIN_SRC emacs-lisp
(defun ans/ess-drake-readd ()
  "Run `drake::readd` on symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "drake::readd('%s')"))

(defun ans/ess-drake-loadd ()
  "Run `drake::loadd` on symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "drake::loadd('%s')"))
#+END_SRC
*** Object names and structure

#+BEGIN_SRC emacs-lisp
(defun ans/ess-names ()
  "Run `names` on symbol at point."
  (interactive)
  (ans/ess-do-with-symbol-at-point "names(%s)"))

(defun ans/ess-str (arg)
  "Run `names` on symbol at point. Optional prefix argument sets `max.level`."
  (interactive "P")
  (let* ((m (if arg (number-to-string arg) "NA"))
         (do-string (concat "str(%s, max.level = " m ")")))
    (ans/ess-do-with-symbol-at-point do-string)))
#+END_SRC
*** Graphics device

#+BEGIN_SRC emacs-lisp
(defun ans/ess-dev-off ()
  "Turn off the current graphics device."
  (interactive)
  (ess-send-string
   (ess-get-process)
   "dev.off()"))
#+END_SRC
** ox-ravel

#+BEGIN_SRC emacs-lisp :tangle no
;; ox-ravel -- Better R integration into org mode
(require 'ox-ravel)
#+END_SRC

** Custom imports functions

Parse, and quickly add to, ~import::from(package, function, ...)~ lists.
This was a nice opportunity to play with some more serious Lisp coding.

The general idea is that a script or function will have an imports list that looks something like:

#+BEGIN_SRC R :eval no :tangle no
# begin imports
import::from("dplyr", "select", "mutate", "bind_rows", .into = "")
import::from("tidyr", "gather", "spread", .into = "")
# end imports
#+END_SRC

My function searches for ~begin imports/end imports~, then converts them lists where the first element is the package and every subsequent element is a function.
The objective is to get a system where, with the point over ~package::function~, I run an interactive function ~ans/imports/add-to-imports~, which will check if the package-function combination is in the imports, and if not, add it intelligently.

This code makes extensive use of the [[https://github.com/magnars/s.el][s.el]] (string manipulation) and [[https://github.com/magnars/dash.el][dash.el]] (list manipulation) libraries.

#+BEGIN_SRC emacs-lisp
(defun ans/import/R-pkg-fun-word-at-point ()
  "Select a package::function statement as a word."
  (let (($temp-syn-table (make-syntax-table ess-r-mode-syntax-table)))
    (modify-syntax-entry ?: "w" $temp-syn-table)
    (modify-syntax-entry ?_ "w" $temp-syn-table)
    (with-syntax-table $temp-syn-table
      (thing-at-point 'word t))))

(defun ans/import/R-pkg-delete-namespace ()
  "Replace package::function with just function."
  (interactive)
  (save-excursion
   (let (($temp-syn-table (make-syntax-table ess-r-mode-syntax-table)))
     (modify-syntax-entry ?: "w" $temp-syn-table)
     (modify-syntax-entry ?_ "w" $temp-syn-table)
     (with-syntax-table $temp-syn-table
       (let* ((bounds (bounds-of-thing-at-point 'word))
              (start (car bounds))
              (end (cdr bounds))
              (thing (ans/import/R-pkg-fun-word-at-point))
              (fun (nth 1 (ans/import/split-pkg-fun-call thing))))
         (delete-region start end)
         (goto-char start)
         (insert fun))))))

(defun ans/import/split-pkg-fun-call (word)
  "Split WORD containing package::function into package and function."
  (s-split "::" word))

(defun ans/import/import-to-list (import-string)
  "Grab IMPORT-STRING and convert to a list.

  The first element of this list is the package and the remaining statements are imports."
  (let* ((import-list (s-with import-string
                        (s-chop-prefix "import::from(")
                        (s-chop-suffix ")")
                        (s-split ", +")))
         (no-into (-remove (lambda (s) (s-matches? "\.into +=" s)) import-list)))
    (mapcar (lambda (s) (s-with s (s-chop-prefix "\"") (s-chop-suffix "\""))) no-into)))

(defun ans/import/find-import-lists ()
  "Find the nearest imports list from the current buffer, and return
    their start and end points as a list.

  Imports lists start with the comment string 'begin imports' and end
  with 'end imports'."
  (let* ((import-start (save-excursion
                         (re-search-backward "#+ *begin imports" nil t)
                         (forward-line)
                         (point)))
         (import-end (save-excursion
                       (goto-char import-start)
                       (re-search-forward "#+ *end imports" nil t)
                       (forward-line -1)
                       (end-of-line)
                       (point))))
    (when (and import-start import-end)
      (list import-start import-end))))

(defun ans/import/parse-import-lists (import-block-string)
  "Convert block of import statements into a list of import strings.

  In the process, remove extraneous whitespace."
  (let* ((import-block-list
          (s-with import-block-string
            (s-collapse-whitespace)
            (s-match-strings-all "import::from(.*?)"))))
    (-map 'ans/import/import-to-list (-flatten import-block-list))))

(defun ans/import/read-imports ()
  "Read and parse current buffer's imports block."
  (let* ((import-start-end (ans/import/find-import-lists))
         (import-block (buffer-substring-no-properties
                        (nth 0 import-start-end)
                        (nth 1 import-start-end))))
    (ans/import/parse-import-lists import-block)))

(defun ans/import/list-to-import (import-list)
  "Convert import-list to a formatted import string."
  (let* ((import-list-q (mapcar (lambda (s) (s-wrap s "\"")) import-list))
         (imports-joined (s-join ", " import-list-q)))
    (s-with imports-joined (s-prepend "import::from(") (s-append ", .into = \"\")"))))

(defun ans/import/replace-imports (import-start-end new-imports)
  "Replace imports list at IMPORT-START-END with NEW-IMPORTS."
  (delete-region (nth 0 import-start-end) (nth 1 import-start-end))
  (let* ((import-string-list (-map 'ans/import/list-to-import new-imports))
         (import-string (s-join "\n" import-string-list))
         (start (nth 0 import-start-end))
         (end (nth 1 import-start-end)))
    (save-excursion
      (goto-char start)
      (insert import-string)
      (indent-region start (max end (point-at-eol))))))

(defun ans/import/search-function (fun)
  "Search for R packages containing FUN."
  (let* ((search-command (format "out <- help.search('^%s$', fields = c('name', 'alias'), ignore.case = TRUE)" fun))
         (result-command "cat(with(out[['matches']], unique(sprintf('%s::%s', Package, Entry))))")
         (complete-command (concat "Rscript -e \"" search-command ";" result-command "\""))
         (raw-result (shell-command-to-string complete-command))
         (split-result (s-split " " raw-result)))
    (if (> (length split-result) 1)
        (completing-read "Which package? " split-result)
      (car split-result))))

(defun ans/import/add-to-imports (arg)
  "Add the current thing to the imports list and update the imports list.
Unless called with prefix argument ARG, also delete the namespace from the current call.

If the thing at point is just a bare function without a namespace, try to identify the function's package."
  (interactive "P")
  (let* (fun addition is_namespaced)
    (setq fun (ans/import/R-pkg-fun-word-at-point))
    (setq is_namespaced (s-contains? "::" fun))
    ;; If it's just a function, try to find it on the search path
    (when (not is_namespaced)
      (setq fun (ans/import/search-function fun)))
    (setq addition (ans/import/split-pkg-fun-call fun))
    ;; If current word isn't parse-able as "package::function", do nothing.
    (when (= (length addition) 2)
      ;; Replace "package::function" with just "function", unless called
      ;; with a prefix argument.
      (when (and (not arg) is_namespaced) (ans/import/R-pkg-delete-namespace))
      (let ((current-imports (ans/import/read-imports))
            (import-bounds (ans/import/find-import-lists)))
        (if (= (length current-imports) 0)
            ;; There are no current imports. Just add it!
            (ans/import/replace-imports import-bounds (list addition))
          ;; There are existing imports
          (let* ((current-packages (mapcar 'car current-imports))
                 (addition-package (nth 0 addition))
                 (i-current-package (-find-index (-partial 's-equals? addition-package) current-packages))
                 (new-imports
                  (if (not (-contains? current-packages addition-package))
                      ;; No other functions imported from this package
                      ;; yet. Just append to the current imports list.
                      (append current-imports (list addition))
                    (let* ((new-function (nth 1 addition))
                           (add-to-package (nth i-current-package current-imports)))
                    ;; At least one function has been imported. Is it
                    ;; this one? (If so, no need to add, so do nothing.)
                      (if (not (-contains? add-to-package new-function))
                          ;; Append the current function to the
                          ;; current package list.
                          (-replace-at
                           i-current-package
                           (append add-to-package (list new-function)) current-imports)
                        current-imports)))))
            (ans/import/replace-imports (ans/import/find-import-lists) new-imports)))))))

(defun ans/import/source-imports ()
  "Source the current imports block."
  (interactive)
  (save-excursion
    (let* (start-end start end)
      (setq start-end (ans/import/find-import-lists))
      (setq start (nth 0 start-end))
      (setq end (nth 1 start-end))
      (ans/ess-tidy-region start (+ end 1))
      ;; Have to do it again because region has changed
      (setq start-end (ans/import/find-import-lists))
      (setq start (nth 0 start-end))
      (setq end (nth 1 start-end))
      (ess-send-region (ess-get-process) start end nil "Re-loaded imports"))))
#+END_SRC

* LaTeX
** LaTeX core configuration

#+BEGIN_SRC emacs-lisp
(use-package tex
  :defer t
  :ensure auctex
  :mode ("\\.tex\\'" . LaTeX-mode)
  :init
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t)
  :config
  (add-hook 'LaTeX-mode-hook 'ans-latex-mode-setup)
  (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook #'TeX-revert-document-buffer))

(defun ans-latex-mode-setup ()
  "Set custom options for LaTeX files."
  (require 'reftex)
  ;; Use settings for text mode
  (ans-text-mode-setup)
  ;; Use the "default" vim paragraph definition
  (setq paragraph-start "\f\\|[ 	]*$")
  (setq paragraph-separate "[ 	\f]*$"))
#+END_SRC
** auctex-latexmk

#+BEGIN_SRC emacs-lisp
(use-package auctex-latexmk
  :ensure t
  :after tex
  :init
  (setq auctex-latexmk-inherit-TeX-PDF-mode t)
  :config
  (auctex-latexmk-setup))
#+END_SRC
** helm-bibtex

#+BEGIN_SRC emacs-lisp
(use-package helm-bibtex
  :ensure t
  :after org-ref
  :init
  (setq bibtex-completion-bibliography ans/reference-bibfile
        bibtex-completion-library-path ans/reference-dir-pdfs
        bibtex-completion-notes-path ans/reference-notes
        bibtex-autokey-name-case-convert-function 'downcase
        bibtex-autokey-name-year-separator "_"
        bibtex-autokey-year-title-separator "_"
        bibtex-autokey-year-length 4
        bibtex-autokey-titlewords 1
        bibtex-autokey-titleword-length nil
        bibtex-autokey-titleword-case-convert-function 'downcase)
  (setq bibtex-completion-additional-search-fields '(journal keywords))
  (setq bibtex-completion-display-formats
        '((t . "${author:36} ${journal:30} ${title:*} ${year:4} ${=has-pdf=:1}${=has-note=:1} ${keywords:20}")))
  (setq bibtex-completion-notes-template-one-file
"** TODO ${author-abbrev} (${year}): ${title}
:PROPERTIES:
:Custom_ID: ${=key=}
:AUTHOR: ${author-or-editor}
:FULL_TITLE: ${title}
:JOURNAL: ${journal}
:YEAR: ${year}
:VOLUME: ${volume}
:PAGES: ${pages}
:DOI: ${doi}
:URL: ${url}
:END:
cite:${=key=}
")
  :commands (helm-bibtex)
  :config
  (helm-delete-action-from-source "Edit notes" helm-source-bibtex)
  (helm-add-action-to-source "Edit notes" 'ans/org-ref-notes-function helm-source-bibtex 7)
  (defun bibtex-completion-fallback-candidates ()
    "Custom list of bibtex fallback options. This is the same as the
one that ships with helm-bibtex, except that
`bibtex-completion-fallback-options` comes first."
    (let ((bib-files (bibtex-completion-normalize-bibliography 'main)))
      (-concat
       bibtex-completion-fallback-options
       (--map (cons (s-concat "Create new entry in " (f-filename it))
                    `(lambda (_search-expression) (find-file ,it) (goto-char (point-max)) (newline)))
              bib-files))))
  (advice-add 'bibtex-completion-candidates
              :filter-return 'reverse)
  (evil-ex-define-cmd "bib[tex]" 'helm-bibtex)
  (general-def
    :states 'emacs
    :keymaps 'biblio-selection-mode-map
    "I" 'ans/biblio-selection-insert-end-of-bibfile))
#+END_SRC

Custom function to insert bibtex entry at the end of my ~library.bib~ file.

#+BEGIN_SRC emacs-lisp
(defun ans/biblio--selection-insert-at-end-of-bibfile-callback (bibtex entry)
  "Add BIBTEX (from ENTRY) to end of library.bib file."
  (with-current-buffer (find-file-noselect ans/reference-bibfile)
    (goto-char (point-max))
    (newline)
    (insert bibtex)
    (org-ref-clean-bibtex-entry)
    (newline)
    (save-buffer))
  (message "Inserted bibtex entry for %S."
           (biblio--prepare-title (biblio-alist-get 'title entry))))

(defun ans/biblio-selection-insert-end-of-bibfile ()
  "Insert BibTeX of current entry at the end of my library.bib file."
  (interactive)
  (biblio--selection-forward-bibtex #'ans/biblio--selection-insert-at-end-of-bibfile-callback))
#+END_SRC

When automatically creating a bibtex key, replace non-ASCII characters to avoid invalid key errors.

#+BEGIN_SRC emacs-lisp
(defun ans/asciify-string (string)
  "Use iconv to convert non-ASCII characters in STRING to ASCII equivalents."
  (with-temp-buffer
    (insert string)
    (call-process-region (point-min) (point-max)
                         "iconv" t t nil "--to-code=ASCII//TRANSLIT")
    (let*
        ((result (buffer-substring-no-properties (point-min) (point-max)))
         (result (replace-regexp-in-string "[^[:alnum:][:blank:]_-]" "" result)))
      result)))

(defun ans/custom-org-clean-function (key)
  "Remove special characters from Bibtex key."
  (replace-regexp-in-string ":" "" key)
  (ans/asciify-string key))

(setq org-ref-clean-bibtex-key-function 'ans/custom-org-clean-function)
#+END_SRC

** ebib

In general, [[helm-bibtex][helm-bibtex]] and [[org-ref]] provide a pretty solid interface for working with references.
However, it's nice to have a more sophisticated solution for organizing a bibtex file.
Ebib provides a nice, Zotero-like interface to bib files that is easier to work with than the raw bibfiles.
Here, I tell Ebib to grab my default, global library, and modify its default keybindings with more evil-friendly ones.

#+BEGIN_SRC emacs-lisp
(use-package ebib
  :ensure t
  :commands ebib
  :init
  (add-to-list 'evil-emacs-state-modes 'ebib-index-mode)
  (setq ebib-preload-bib-files '("~/Dropbox/references/library.bib"))
  :config
  (setq ebib-index-columns '(("Entry Key" 40 t)
                             ("Author/Editor" 40 t)
                             ("Year" 6 t)
                             ("Journal" 20 t)
                             ("Title" 80 t)))
  (general-def
    :keymaps 'ebib-index-mode-map
    :states 'emacs
    "j" 'ebib-next-entry
    "k" 'ebib-prev-entry
    "d" 'ebib-kill-entry
    "p" 'ebib-yank-entry
    "SPC" ans-leader-map))
#+END_SRC
* Editing tools
** rebox2

Edit comment boxes.

#+BEGIN_SRC emacs-lisp
(use-package rebox2
  :ensure t
  :general
  (ans-leader-def
    :states 'normal
    "gR" 'rebox-mode
    "gr" 'rebox-dwim)
  :config
  (add-to-list 'rebox-language-character-alist '(7 . "!"))
  (setq rebox-regexp-start (vconcat rebox-regexp-start '("^[ \t]*!+")))
  (rebox-register-all-templates))
#+END_SRC
** flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config
  (global-flycheck-mode)
  (general-def
    :states '(motion normal)
    "]a" 'flycheck-next-error
    "[a" 'flycheck-previous-error
    "]A" 'flycheck-first-error)
  (ans-leader-def
    :states '(motion normal)
    "&" 'flycheck-list-errors)
  (defun disable-flycheck-in-org-src-edit ()
    "Disable some Flycheck features when editing an org src block."
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
  (add-hook 'org-src-mode-hook 'disable-flycheck-in-org-src-edit))
#+END_SRC
** simpleclip

#+BEGIN_SRC emacs-lisp
(use-package simpleclip
  :ensure t
  :config
  (simpleclip-mode 1)
  (setq select-enable-clipboard t
        x-select-enable-clipboard t))
#+END_SRC
** smartparens

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config
  (require 'smartparens-config)
  (general-def
    :states 'insert
    "C-0" 'ans/sp-slurp-and-end
    "C-9" 'sp-forward-barf-sexp)
  (general-def
    :states '(motion normal visual insert)
    "M-]" 'sp-end-of-sexp
    "M-[" 'sp-beginning-of-sexp
    "M-." 'sp-next-sexp
    "M-," 'sp-backward-sexp))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun ans/sp-slurp-and-end ()
  "Slurp up sexp and move to its end."
  (interactive)
  (sp-forward-slurp-sexp)
  (sp-end-of-sexp))
#+END_SRC

Here's a hydra for navigating lisp code.

#+BEGIN_SRC emacs-lisp :tangle no
(setq sp-navigate-interactive-always-progress-point t)

(defhydra ans/smartparen-hydra (:foreign-keys run)
  "Smartparens"
  ("n" sp-next-sexp "Next")
  ("p" sp-previous-sexp "Prev")
  ("f" sp-forward-sexp "Forward")
  ("b" sp-backward-sexp "Backward")
  ("k" sp-up-sexp "Up")
  ("j" sp-down-sexp "Down")
  ("e" sp-end-of-sexp "End")
  ("b" sp-beginning-of-sexp "Beginning")
  ("-" sp-split-sexp "Split")
  ("J" sp-join-sexp "Join")
  ("q" nil "Quit"))
#+END_SRC
** lispyville

#+BEGIN_SRC emacs-lisp
(use-package lispyville
  :ensure t
  :hook ((lisp-mode emacs-lisp-mode lisp-interaction-mode) . lispyville-mode))
#+END_SRC

** edit-server

#+BEGIN_SRC emacs-lisp
;; For editing text fields in the browser
(use-package edit-server
  :ensure t
  :config
  (edit-server-start))
#+END_SRC
** adaptive-wrap

#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap
  :ensure t
  :hook (visual-line-mode . adaptive-wrap-prefix-mode))
#+END_SRC
** expand-region

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :init
  (setq expand-region-contract-fast-key ",")
  :general
  (general-def
    :states 'motion
    "z." 'er/expand-region))
#+END_SRC
** fill-function-arguments

#+BEGIN_SRC emacs-lisp
(use-package fill-function-arguments
  :quelpa (fill-function-arguments
           :fetcher github
           :repo "davidshepherd7/fill-function-arguments")
  :general
  (general-def
    :states 'normal
    "gs" 'ans/fill-function-arguements-and-indent))
#+END_SRC

Define a custom function that calls ~fill-function-arguments~ and then re-indents the expression.

#+BEGIN_SRC emacs-lisp
(defun ans/fill-function-arguements-and-indent ()
  "Fill function arguments and indent."
  (interactive)
  (fill-function-arguments-dwim)
  (let ((start (save-excursion (sp-beginning-of-sexp) (point)))
        (end (save-excursion (sp-end-of-sexp) (+ (point) 1))))
    (indent-region start end)))
#+END_SRC

** aggressive-indent

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :disabled
  ;; :ensure t
  :hook (prog-mode . aggressive-indent-mode)
  :config
  (add-to-list 'aggressive-indent-excluded-modes 'makefile-mode)
  (ans-leader-def
    :states 'normal
    "I" 'aggressive-indent-mode))
#+END_SRC
** undo-tree

NOTE: This is temporarily disabled.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :disabled
  :ensure t
  :init
  (setq undo-tree-history-directory-alist `(("." . "~/.emacs.d/undo"))
        undo-tree-auto-save-history t)
  :config
  (global-undo-tree-mode))
#+END_SRC
** hl-todo

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :ensure t
  :config
  (global-hl-todo-mode)
  (defhydra hl-todo-hydra ()
    "Browse todo tags."
    ("n" hl-todo-next "Next")
    ("p" hl-todo-previous "Previous"))
  (ans-leader-def
    :states 'normal
    "t" 'hl-todo-hydra/body))
#+END_SRC

Function to use ~org-ref~ for notes rather than bibtex defaults.

#+BEGIN_SRC emacs-lisp
(defun ans/org-ref-notes-function (candidates)
  "Helm bibtex completion function to insert notes for marked CANDIDATES."
  (let ((key (helm-marked-candidates)))
    (funcall org-ref-notes-function (car key))))
#+END_SRC
** dumb-jump

Quickly jump to definitions based on regular expression search (not tags or anything more robust).

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :init
  (setq dumb-jump-selector 'helm)
  (setq dumb-jump-force-searcher 'ag)
  :general
  (general-def
    :states 'normal
    "gd" 'dumb-jump-go
    "gD" 'ans/dumb-jump-hydra/body))

(defhydra ans/dumb-jump-hydra (:exit t)
  "Dumb jump."
  ("d" dumb-jump-go "Go")
  ("D" evil-goto-definition "Evil goto def")
  ("o" dumb-jump-go-other-window "Other window")
  ("b" dumb-jump-back "Back"))
#+END_SRC
** slime

Superior Lisp Interaction Mode for Emacs (SLIME)

#+BEGIN_SRC emacs-lisp
(use-package slime
  :ensure t
  :ensure-system-package sbcl
  :commands slime
  :init
  (setq inferior-lisp-program "/usr/bin/sbcl"))
#+END_SRC

** dtrt-indent

Automatically detect current file indent (similar to =vim-sleuth=).

#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t)
#+END_SRC

** ANSI colors in compilation buffer

So the output doesn't come out as jumbled.
Based on [[https://stackoverflow.com/questions/13397737/ansi-coloring-in-compilation-mode][this Stack Overflow question]].

#+BEGIN_SRC emacs-lisp
(require 'ansi-color)
(defun ans/colorize-compilation-buffer ()
  "Add ANSI colors to compilation buffer."
  (toggle-read-only)
  (ansi-color-apply-on-region compilation-filter-start (point))
  (toggle-read-only))
(add-hook 'compilation-filter-hook 'ans/colorize-compilation-buffer)
#+END_SRC

** deadgrep

#+BEGIN_SRC emacs-lisp
(use-package deadgrep
  :ensure-system-package rg
  :ensure t
  :general
  (ans-leader-def
    :states '(normal visual)
    "rg" #'deadgrep)
  :config
  (setq deadgrep-project-root-function #'ans/try-projectile-project-root))

(defun ans/try-projectile-project-root ()
  "Use project"
  (let* ((dir (projectile-project-root)))
    (if dir dir
      (deadgrep--project-root))))
#+END_SRC
* Terminal
** Multi-term

Better terminal emulator inside Emacs.
Based on [[http://paralambda.org/2012/07/02/using-gnu-emacs-as-a-terminal-emulator/][this guide]].

Currently disabled.

#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :ensure t
  :disabled
  :init
  (setq multi-term-buffer-name "*term*"
        multi-term-program "/bin/bash")
  :general
  (ans-leader-def
    :states 'normal
    "!" #'multi-term))
#+END_SRC
** Eshell

Terminal emulator in Emacs lisp.
Currently using this one.

#+BEGIN_SRC emacs-lisp
(ans-leader-def
  :states 'normal
  "!" #'eshell)
#+END_SRC
